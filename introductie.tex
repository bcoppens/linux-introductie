\documentclass[a4paper,twoside,openany]{memoir}
\usepackage[dutch]{babel}
\usepackage{hyperref}
\usepackage{fullpage}

\epigraphfontsize{\small\itshape}
\setlength\epigraphwidth{8cm}
\setlength\epigraphrule{0pt}

\begin{document}

\epigraphfontsize{\small\itshape}

\chapter{Inleiding tot Linux}
\epigraph{``It’s a Unix system, I know this!''}{--- \textup{Lex Murphy}, Jurassic Park}

De komende drie weken gaan we een korte inleiding geven tot Linux. Maar wat is
Linux? Strikt genomen is Linux niet meer dan een \emph{operating system kernel}:
deze zorgt er achter de schermen voor dat je verschillende programma's kan
starten en tegelijkertijd laten draaien, dat de invoer die je via een
toetsenbord ingeeft bij de programma's toekomt, dat deze programma's iets op
het scherm kunnen printen als uitvoer, etc. Een gebruiker interageert echter
niet direct met de (Linux-)kernel, maar eerder met programma's die als interface
dienen. Meestal voorzien deze programma's een grafische interface: je bent dit
wel gewend uit Windows en OS X, en deze interfaces bestaan ook onder Linux,
zoals KDE en Gnome. Grafische, intuïtieve, interfaces zijn echter pas redelijk
laat in gebruik genomen. Voorafgaand de opkomst van de grafische interface aan
was er een andere interface die de computerwereld domineerde: de
\emph{command-line} interface.

Deze inleidende sessies gaan over de command-line interface (of
\emph{commandolijninterface}). Deze is  helaas (veel) minder intuïtief, maar
daarom niet minder belangrijk is om wat ervaring mee te hebben. Met enige kennis
van de command-line programma's, en hoe je die kan combineren met elkaar, kan je
je leven later (hopelijk) veel makkelijker maken (en dat niet alleen in de
eigenlijke practica van \emph{computerarchitectuur}, maar ook in andere vakken
van de opleidingen computerwetenschappen en elektrotechniek, en misschien zelfs
je thesis). Een grote sterkte van de command line op Linux (die voortvloeit uit
een rijke traditie van command line interfaces die ontstaan is in de jaren '70
en '80 en ontwikkeld werden voor Unix-systemen), is dat deze het zeer eenvoudig
maken om zeer complexe tekstoperaties en bestandssysteemoperaties met elkaar te
combineren. De uitvoer van veel programma's is simpelweg tekst, wat het
uitermate handig maakt om de uitvoer van programma's te filteren, combineren,
etc. Bij wijze van voorbeeld: je kan alle PDF-bestanden zoeken op je systeem, en
die dan filteren op degenen die de tekst \emph{``Voorstel tot het bevriezen van
$n$ postgraduaatsopleidingen''} bevatten, waarbij $n$ gelijk welk natuurlijk
getal is; je kan de uitvoer van een simulator zo herstructureren dat je de
interessante data rechtstreeks in een spreadsheet kan plakken, etc.

\section{Organisatie van de sessies}

Deze inleidende sessies gaan door tijdens de eerste drie lesweken, elke dinsdag
van 8u30 tot 9u40, in PC-klassen A en B in de Plateau. Je gaat hier op twee
manieren met Linux leren werken:

\begin{enumerate}

  \item Met enkele oefeningen op Dodona. Deze oefeningen zullen gradueel
    beschikbaar gemaakt worden op de Dodona-site die je kan vinden op
    \url{https://dodona.ugent.be/nl/courses/79/}.

  \item Door te oefenen op een virtueel Linux-systeem dat jullie in VirtualBox
    zullen opzetten. Installeer hiervoor eerst VirtualBox
    (\url{https://www.virtualbox.org/}), end download onze image op
    \url{https://users.elis.ugent.be/~bcoppens/kubuntu-computerarchitectuur.7z}.
    \textbf{Gelieve deze stappen reeds op voorhand te voltooien zodat we hier
    tijdens de labo's zelf niet te veel tijd aan verliezen.} Indien je wil
    werken op een PC in de practicumzaal, zet dan best de (gedecomprimeerde)
    image al op een USB stick. Op dit Linux-systeem hebben we voor jullie al
    een gebruiker \emph{student} aangemaakt wiens \textbf{wachtwoord} ook
    simpelweg \emph{student} is.

\end{enumerate}

De structuur van de sessies zal er als volgt uitzien (voorlopige planning, onder voorbehoud):

\begin{itemize}

  \item \emph{Week 1}: Inleiding tot de command line, de meest simpele
    bestandssysteemoperaties, eenvoudige tekstoperaties, en \emph{reguliere
    expressies}.

  \item \emph{Week 2}: Het combineren van verschillende operaties tot veel
    krachtigere en complexere pijplijnen aan de hand van \emph{pipes} en
    \emph{redirects}, geavanceerdere reguliere expressies, en hoe simpele
    C(++)-programma's te compileren vanaf de command line.

  \item \emph{Week 3}: Meer geavanceerde toepassingen van de concepten van de
    eerste twee weken, Linux-systemen op het internet beheren met een
    \emph{remote shell}, en een korte introductie tot \emph{git}.

\end{itemize}

Het materiaal behorende tot weken 2 en 3 zal voor die lessen online komen.
\textbf{Deze handleiding zal dus ook nog twee keer aangepast worden met het nu
nog ontbrekende materiaal van weken 2 en 3!}

\section{Acknowledgements}
Deze tekst werd in hoofdzaak geschreven door Bart Coppens en Bert Abrath. Verder
kregen we een zeer nuttige opmerking van Simon Bil.

\part{Week 1}
\chapter{Het bestandssysteem in Linux}
Voor we beginnen met het echte werk, is het nuttig om enkele basisconcepten
te kennen van het bestandssysteem, en hoe je kan verwijzen naar bestanden.

Standaard zijn alle verwijzingen naar bestanden \emph{relatief ten opzichte van
de huidige directory}. Dus als je weet dat je directory zit die een
(sub)directory \verb!computerarchitectuur_practica! bevat, kan
je met de verwijzijng \verb!computerarchitectuur_practica! direct naar deze
subdirectory verwijzen.

Directories en bestanden daarin worden van elkaar gescheiden door een forward
slash (/). Dus, \verb!computerarchitectuur_practica/README! verwijst naar
het \verb!README!-bestand in de \verb!computerarchitectuur_practica! directory.

Merk op dat voor Linux een directory eigenlijk een speciaal bestand is. Dus
als je vraagt om alle bestanden in een directory op te lijsten, zal je dus
niet alleen de `gewone' bestanden zien, maar ook alle (sub)directories.

Je kan ook werken met \emph{absolute paden}. In Windows is dit typisch iets wat
begint met \verb!C:\!, \verb!D:\!, etc.. In Unix-gebaseerde systemen zoals
Linux (maar ook OS X),
beginnen deze echter steeds met een initiële forward slash. Alle bestanden zijn
dus te vinden via verwijzingen die starten vanaf de zogeheten
\emph{root-directory}. Al je schijven, USB-sticks, etc., zitten in eenzelfde
directorystructuur. Een voorbeeld van zo'n pad is de
home-directory van de gebruiker: \verb!/home/student!. Dit wil zeggen dat we starten vanaf de
root-directory \verb!/!, die een subdirectory \verb!home! bevat, die dan op zijn
beurt een subdirectory \verb!student! bevat.


\chapter{Inleiding tot de command line}

Start in je Linux virtuele machine een \emph{terminal} op door het programma
\emph{Konsole} te starten. (Zoals zo vaak in de Linux-wereld zijn er
duizend-en-één verschillende mogelijkheden beschikbaar, waarvan Konsole er
slechts één is.) Eerst gaat dit wat uitvoer produceren die je voorlopig mag
negeren (er start namelijk een programma dat automatisch de meest recente
opgaves op je systeem zal downloaden). Na even te wachten, zal je dan volgende
\emph{prompt} te zien krijgen:

\begin{verbatim}
student@student-VirtualBox:~$ 
\end{verbatim}

Deze prompt vraagt (of `prompt') achter nieuwe commando's om uit te voeren. De
tekst duidt aan dat deze sessie draait op het systeem genaamd
\emph{student-VirtualBox} (later zullen we inloggen op een ander systeem met een
andere naam), als gebruiker \emph{student}. De naam van de gebruiker vind je dus
voor de \texttt{@}, de naam van het systeem na de \texttt{@}. Wat er tussen de
\texttt{:} en de \texttt{\$} staat, is de \emph{directory} waar je je op dit
moment bevindt. Standaard zal een terminal starten in de \emph{home-directory}
van de ingelogde gebruiker; deze wordt doorgaans afgekort als \texttt{\~}.

Om er achter te komen in welke directory we ons eigenlijk bevinden, gaan we het
eerste commando invoeren, \verb!pwd! (\emph{Print Working Directory}):

\begin{verbatim}
student@student-VirtualBox:~$ pwd
/home/student
\end{verbatim}

In de loop van deze sessies zal je nog veel meer van deze commando's tegenkomen
met enigszins obscure namen, waar je een hele reeks meer en minder gekende
opties aan kan meegeven. Om meer te lezen over een bepaald commando en de opties
die het ondersteunt kan je beroep doen op de \emph{man-pages}, die een soort van
handleiding vormen. Je kan deze opvragen met het commando \verb!man!. Stel je
voor dat je je afvraagt wat de mogelijke opties zijn van het \verb!ls!-commando
(dat we zometeen gaan zien). Dit doe je via:

\begin{verbatim}
student@student-VirtualBox:~$ man ls
\end{verbatim}
waarna je in een zeer simpele textviewer terecht komt met de handleiding van het
\verb!ls!-commando. Helemaal bovenaan staan heel summiere uitleg van wat het
programma doet, een summier overzicht van de mogelijke opties, gevolgd door een
heel uitgebreide beschrijving van al die opties, eventueel gevolgd door
voorbeelden en aandachtspunten. Deze viewer moet echter ook op een specifieke
manier bediend worden:

\begin{itemize}

  \item \emph{Scrollen} door de tekst kan je met de pijltjes omhoog en omlaag,
    en door PageUp en PageDown.

  \item \emph{Zoeken} door de tekst, kan je door forward slash (`/') te typen,
    gevolgd door je zoekterm (als je bijvoorbeeld in het geval van \verb!ls! wil
    weten hoe de uitvoer gesorteerd kan worden, kan je `sort' typen), en dan op
    \emph{enter} duwen. Alle hits op die zoekterm zullen oplichten in de tekst,
    en de viewer springt automatisch naar de eerste hit. Je kan bovendien
    eenvoudig naar de volgende/vorige hit in de tekst gaan met respectievelijk
    de toetsen `n' (\emph{next}) en `p' (\emph{previous}).

  \item {Afsluiten} van de viewer kan je doen door de `q'-toets (\emph{quit}).

\end{itemize}

\chapter{Simpele bestandssysteemoperaties}

We gaan een aantal heel simpele bestandssysteemoperaties bekijken. Vergeet niet
dat je meer details hierover (zoals extra opties) kan opzoeken in de relevante
man-pages.

\section{\texttt{ls} --- List Files/Directory Contents}

Het \verb!ls!-commando laat toe om de inhoud van een directory te bekijken, en
om meer details over de  bestanden weer te geven. Als je geen specifieke
bestanden of directories meegeeft als argument, dan zal het informatie
uitprinten over de huidige
directory. Standaard zal het \emph{énkel} de lijst van bestanden (en dus ook
directories) in de huidige directory uitprinten:

\begin{verbatim}
student@student-VirtualBox:~$ ls
computerarchitectuur_practica Desktop Documents Downloads Music Pictures Public
Templates Videos
\end{verbatim}

Dit wil dus zeggen dat je home-directory 9 bestanden (in dit geval alleen
directories) bevat.

Je de bestanden in die (sub)directory als volgt printen: \verb!ls computerarchitectuur_practica!
(merk dus op dat we hier nu gebruiken van een relatief pad). Je kan even
goed ook verwijzen naar een subdirectory: Nu je weet dat in die directory
een subdirectory \verb!pract01!
zit, kan je die inhoud laten zien door het commando
\verb!ls computerarchitectuur_practica/pract01!
te typen.


\textbf{Belangrijke tip!} Je gaat het misschien net als ik ook al beu zijn om
elke keer opnieuw \verb!computerarchitectuur_practica! voluit te typen. Dat is
saai, traag, en foutgevoelig. De \emph{shell} (het programma waarmee je
interageert in de terminal en die je \verb!student@student-VirtualBox:~$!
print), heeft gelukkig een feature die dit probleem zo goed als volledig oplost:
\emph{tab completion}. Je typt gewoon het begin van een bestand/directory, en
drukt de tab-toets in. De shell zal dan zo ver mogelijk aanvullen als hij kan,
gegeven de bestanden in de directory. Dus bij
\verb!computerarchitectuur_practica! weet je nu dat dit het \'enige bestand is
in de home-directory dat begint met de letter \verb!c!. Dus kan je gewoon typen:
\verb!ls c!\emph{tab}, waarna automatisch alles wordt aangevuld. Die directory
heeft nu 8 practica-subdirectories. Dus kan je
\verb!computerarchitectuur_practica/p!\emph{tab} typen, waarna dit wordt
aangevuld tot \verb!computerarchitectuur_practica/pract0!. Aangezien er echter 8
verschillende subdirectories zijn, kan de shell dit uiteraard niet aanvullen tot
op het einde. In dit geval is het handig om 2 keer op tab te duwen:
\verb!computerarchitectuur_practica/pract0!\emph{tab} \emph{tab}: dan laat de
shell alle bestanden zien die beginnen met \verb!pract0!, zodat je makkelijk dat
karakter zelf kan typen (en dan eventueel weer verder aan te laten vullen door
weer op \emph{tab} te duwen).

Probeer eens op de volgende 3 manieren de inhoud van
\verb!computerarchitectuur_practica! te laten zien: met een relatief pad, met
een absoluut pad, en met een pad relatief ten opzichte van de shortcut voor de
homedirectory \verb!~!. Maak hierbij gebruik van tab completion.

Je kan ook meer informatie laten printen door \verb!ls!. De meest handige manier
is \verb!ls -lh!, wat onder andere de grootte print van het bestand. Probeer dit
eens uit met \verb!ls -lh /bin/!. Gebruik de man-page om te achterhalen wat de
\verb!l! en \verb!h! opties precies betekenen. (Voor de rest is het allicht ook
interessant om weten dat je kan sorteren op allerhande soorten informatie, als
je meer hierover wil weten kan je dat opzoeken in de man-page.)

\section{\texttt{cd} --- Change Directory}

Enerzijds kennen we nu het concept van `de huidige directory', en anderzijds
weten we hoe \verb!ls! te gebruiken om te zien welke directories (of files) er
waar zijn. Met \verb!cd! kunnen we onze huidige directory veranderen naar de
andere directory. Zo kunnen we naar de
\verb!computerarchitectuur_practica!-directory gaan, en verolgens het
\verb!ls!-commando uitvoeren. De inhoud van de
\verb!computerarchitectuur_practica!-directory zal dan getoond worden:

\begin{verbatim}
student@student-VirtualBox:~$ cd computerarchitectuur_practica
student@student-VirtualBox:~/computerarchitectuur_practica$ ls
pract01 pract02 pract03 pract04 pract05 pract06 pract07
pract08 README
\end{verbatim}

De prompt geeft hier meteen mooi aan dat de huidige directory veranderd is.

Je kan verwijzen naar de bovenliggende directory via \verb!..!. Dit kan je
gebruiken om omhoog te gaan in de directorystructuur:
\begin{verbatim}
student@student-VirtualBox:~/computerarchitectuur_practica$ cd ../..
student@student-VirtualBox:/home$ 
\end{verbatim}

Hier verplaatsen we ons dus naar de bovenliggende directory van de bovenliggende
directory, wat in dit geval \verb!/home! is.

\section{\texttt{mkdir} --- Make Directory}

We kunnen nieuwe directories aanmaken met het \verb!mkdir! commando: \verb!mkdir nieuwedirectory!. De verwijzing naar de nieuwe directory kan zowel relatief als
absoluut zijn, maar standaard gaat het commando er van uit dat slechts de meest
diepe directory moet worden aangemaakt, en alle tussenliggende directories reeds
bestaan. Zoek op in de man-page hoe je \verb!mkdir! deze directories ook kan
laten aanmaken voor je.

\section{\texttt{cp} --- CoPy Files}

Met het \verb!cp!-commando kan je bestanden kopiëren. Er zijn twee mogelijkheden:

\begin{itemize}

  \item Het doel is een bestandsnaam: \verb!cp bestand1 bestand2! zal
    \verb!bestand1! kopiëren naar een bestand met de naam \verb!bestand2!.

  \item Het doel is een directory: \verb!cp bestand1 directory! zal een kopie
    van \verb!bestand1! aanmaken in \verb!directory!; het nieuwe bestand zal (in
    die directory) dezelfde naam hebben als het originele bestand. In dit geval
    kan je ook meerdere bestanden in 1 keer kopieren: \verb!cp bestand1 bestand2 bestand3 directory!.

\end{itemize}

Probeer eens een bestand uit de \verb!/bin!-directory te kopiëren naar een
directory die je zonet hebt aangemaakt, en verifieer dat de kopie even groot is
als het origineel.

\section{\texttt{mv} --- MoVe Files}

Het \verb!mv!-commando werkt net als het \verb!cp!-commando, maar het verplaatst
de bestanden in plaats van ze te kopiëren. Volledig gelijkaardig met \verb!cp!
kan het doel een bestandsnaam of een directory zijn.

\section{\texttt{rm} --- ReMove Files}

Tot slot willen we ook bestanden kunnen verwijderen. Dit kan met het
\verb!rm!-commando.

\section{\texttt{cat} --- Een slechte textviewer}

Het \verb!cat!-commando gaat de inhoud van bestanden die het meekrijgt als
argument gewoon achter elkaar naar scherm printen. Probeer eens een bestand uit
de \verb!computerarchitectuur_practica! directory op scherm te printen.

\section{\texttt{less} --- Een simpele textviewer}

Het \verb!cat!-commando is niet zo handig om tekst mee te bekijken. Het zou veel
handiger zijn als we de textviewer die gebruikt wordt voor de man-pages zouden
kunnen hergebruiken. Gelukkig is dit mogelijk: dit is het \verb!less!-commando.
Probeer met \verb!less! eens hetzelfde bestand te bekijken als je zonet deed met
\verb!cat!.

\section{\texttt{touch} --- Een leeg bestand aanmaken}

Met het \verb!touch!-commando kan je een leeg bestand aanmaken. (Dit commando
heeft eigenlijk een ander doel, zoals je kan lezen in de man-page. Maar als je
het als argument een bestandsnaam geeft die nog niet bestaat, zal het dat
bestand aanmaken.)

Maak in je homedirectory eens een leeg bestand \verb!A! aan. Net zoals bij de
vorige commando's, kan je ook meerdere argumenten aan dit commando meegeven. Elk
van die bestanden zal dan worden aangemaakt.

\textbf{Belangrijk!} De verschillende argumenten van een commando worden door
een spatie van elkaar gescheiden. Maar als nu een van de argumenten een
bestandsnaam is die een spatie bevat, wat dan? Dan kan je dat argument tussen
een koppel enkele quote-tekens (\verb!'!) zetten: alles wat daartussen staat,
wordt beschouwd als hetzelfde argument, inclusief spaties. Als we bijvoorbeeld 3
bestanden willen aanmaken, waarvan één bestand wiens naam spaties bevat, kan je
dit als volgt doen:

\begin{verbatim}
student@student-VirtualBox:~$ touch bestand1 'bestandsnaam 2 met spaties' bestand3
\end{verbatim}

Probeer dit zelf eens, en kijk ook hoe dit er uit ziet met zowel \verb!ls! als
\verb!ls -lh!. Probeer zo'n bestand ook eens te kopiëren. Merk bovendien ook op
dat het geen kwaad kan om ook quote-tekens te zetten rond argumenten zonder
spatie:

\begin{verbatim}
student@student-VirtualBox:~$ touch 'bestand4' 'bestand5'
\end{verbatim}

Dit zal 2 extra bestanden aanmaken, waarbij de quotes geen deel uitmaken van de
bestandsnaam. Je kan in principe ook dubbele quotes (\verb!"zoals dit"!)
gebruiken, maar die hebben een subtiel andere betekenis dan de enkele quote die
ik hierboven demonstreerde. Het verschil zal je zien in sessie 3; gebruik tot
dan voor de veiligheid gewoon de enkele quotes.

\chapter{Simpele tekstoperaties}

Nu gaan we ook echt iets doen met deze tekstbestanden. In deze sessie houden we
het eenvoudig: we gaan simpelweg de inhoud van bestanden doorzoeken en
herordenen.

\section{\texttt{cut} --- Herordenen van kolommen}

Met het \verb!cut!-commando kan je tekstbestanden onderverdelen in kolommen, en
dan een deelverzameling van die kolommen uitprinten op het scherm (in de
volgorde die jij wil). De kolommen (\emph{fields}) die je wil printen, geef je
aan met het argument dat volgt op \verb!-f!. Het \verb!cut!-commando verdeelt
een lijn onder in verschillende kolommen afhankelijk van een \emph{delimiter}.
Zoals je in de man-page al kan zien, is deze delimiter standaard een
tab-karakter, wat in de praktijk nogal onhandig is; die kan je makkelijk
aanpassen met \verb!-d!.

Om een simpel voorbeeld te geven, het bestand \verb!/etc/passwd! bevat
informatie over de gebruikers op het systeem. De verschillende velden zijn van
elkaar gescheiden door een \verb!:!-karakter. Als je dan bijvoorbeeld per
gebruiker de volledige naam (het vijfde veld) en de home-directory van die
gebruiker (het zesde veld) wil uitprinten, kan je dit doen als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ cut -d : -f 5,6 /etc/passwd
\end{verbatim}

Probeer eens een spatie als delimiter te gebruiken?

\chapter{Reguliere expressies}

Reguliere expressies zijn uitdrukkingen die je toestaan om simpele zoekpatronen
(dit zijn dan de expressies) te beschrijven die meer zijn dan enkel letterlijke
stukken tekst. Achter dit concept zit een heel interessante theoretische
achtergrond, die volledig buiten de scope van dit document valt. Wat belangrijk
is, is wat je er mee kan en hoe je ze opbouwt.

Je doorzoekt een of meerdere tekstbestanden met een reguliere expressie als
volgt: \verb!egrep '!\emph{patroon}\verb!' bestand(en)!. Dit gaat alle lijnen
uitprinten in de gegeven bestanden die voldoen aan de gegeven reguliere
expressie/zoekpatroon. Zo'n patroon zet je opnieuw best tussen quotes, niet
alleen omdat een patroon spaties kan bevatten, maar ook omdat bepaalde
zoekpatronen speciale karakters zijn in de shell, en door die in quotes te
zetten verliezen ze hun speciale betekenis.

Een regulier expressie bouw je op uit kleinere sub-expressies. De belangrijkste sub-expressies en manieren om ze op te bouwen zijn:

\begin{itemize}

  \item \emph{Letterlijk karakter:} Dit geef je gewoon letterlijk in.
    Bijvoorbeeld: \verb!egrep 'a' bestand.txt! zoekt geeft alle lijnen die het
    karakter \emph{a} bevatten in het bestand \verb!bestand.txt!

  \item \emph{Aan elkaar plakken van expressies (concatenation)}: door
    expressies achter elkaar te plakken, ga je zoeken op de regels die die
    opeenvolging van expressies bevatten. Zoals je weet van het vorige puntje,
    is een enkel karakter een expressie; je kan die dan zoals je zou verwachten
    achter elkaar typen om volledige zinnen te zoeken. Bijvoorbeeld,
    \verb!egrep 'Linux is tof' bestand.txt! zoekt op de tekst \emph{Linux is
    tof} (dat is dus de opeenvolging van de tekens \emph{L, i, n, etc.} in het
    bestand \verb!bestand.txt!.

  \item \emph{Eender welk karakter:} Als je het \verb!.!-karakter in een
    reguliere expressie op een bepaalde plaats zet, zal gelijk welk karakter
    daar mogen voorkomen. Bijvoorbeeld: \verb!egrep 'm.h' bestand.txt! zal alle
    regels uitprinten die tekst bevatten die de vorm heeft van `m, gevolgd door
    gelijk welk karakter, gevolgd door h'.

  \item \emph{Een bereik (range) van karakters:} soms is \verb!.! te ruim, en
    wil je enkel regels die op een bepaalde positie een beperkt bereik van
    karakters toestaan. Dit kan je doen door al die karakters tussen vierkante
    haakjes te zetten. Bijvoorbeeld: \verb!Bar[td]! is een patroon dat zowel
    \emph{Bart} als \emph{Bard} zal matchen. Als het bereik groot is, maar op
    elkaar volgt in de ASCII-tabel, kan je dit afkorten door een streepje: het
    patroon \verb![a-d]! zal \emph{a,b,c,d} matchen.

  \item \emph{Een keuzemogelijkheid:} als je lijnen wil printen die een van
    meerdere zoekpatronen matcht, kan je die scheiden van elkaar met een
    vertikaal streepje, ook wel het \emph{pipe symbol} genoemd: \verb!|!.
    Bijvoorbeeld, \verb!Aap|Noot|Mies! zal alle lijnen printen die minstens
    eenmaal \emph{Aap}, \emph{Noot}, of \emph{Mies} bevatten.

  \item \emph{Herhaling, 0 of meer keer:} Als je het voorgaande element 0 of
    meer keer wil herhalen, dan zet je hier een asterisk na: \verb!ka*t! zal
    zowel matchen op \emph{kt}, \emph{kat}, \emph{kaat}, etc. Dit werkt
    uiteraard ook op andere types referenties, \verb![0-9]*! zal matchen op
    gelijk welke opeenvolging van cijfers (en ook 0 cijfers).

  \item \emph{Herhaling, 1 of meer keer:}, hiervoor gebruiken we een plus-teken.
    Dus \verb![0-9]+! zal matchen op elk getal, dat minstens uit \'e\'en cijfer
    bestaat.

  \item \emph{Herhaling, bereik:} dit doe je met accolades en het aantal keer
    dat het herhaald wordt ertussen. Bijvoorbeeld, als je exact een Googol wil
    matchen, wat een 1 is gevolgd door 100 0'en, dan kan je dit doen als volgt:
    \verb!10{100}!. (Dus om precies te zijn: het element voor de accolades is
    een 0, en dat moet 100 keer worden herhaald.) Je kan ook een heel bereik
    opgeven (tussen twee getallen, ten hoogste een bepaald getal), de exacte
    syntax hiervan kan je in de man-page van egrep vinden.

  \item \emph{Groeperen:} De bovenstaande operaties slaan steeds op het vorige
    \emph{element} in de expressie. Aangezien individuele karakters ook al
    expressies zijn, wil dit zeggen dat de expressie \verb!Noot{2}! \'enkel zal
    matchen op \emph{Noott} (dus een dubbele \emph{t}), maar ni\'et op
    \emph{NootNoot}. Om die operaties op een samenstelling van expressies te
    zetten, zet je die samenstelling tussen ronde haakjes. Wat tussen ronde
    haakjes staat, zal dan worden aanzien als een enkele expressie. Dus om
    \emph{NootNoot} te matchen, kan je dus de expressie \verb!(Noot){2}!
    gebruiken.

  \item \emph{Begin van een regel:} Dit geef je aan met het teken \verb!^!. Dus
    \verb!^A! gaat enkel op regels matchen die beginnen met een \emph{A}.

  \item \emph{Einde van een regel:} Dit geef je aan met het teken \verb!$!. Dus
    \verb!A$! gaat enkel op regels matchen die eindigen op een \emph{A}.

\end{itemize}

Een voorbeeldje:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd
\end{verbatim}

zal alle regels in \verb!/etc/passwd! uitprinten die eindigen op ofwel
\verb!nologin! ofwel op \verb!false!. Bovendien zal de omgeving die wij
gebruiken, \verb!egrep! standaard zo instellen dat de specifieke delen die
gematcht worden, gekleurd worden, zodat je duidelijk kan zien waar de matchende
expressies voorkomen in elke lijn.

Standaard gaat \verb!egrep! hoofdlettergevoelig zoeken. Dit wil zeggen dat \verb!egrep 'e'! niet hetzelfde is als \verb!egrep 'E'!: het eerste zal enkel lijnen weergeven die een kleine letter \emph{e} bevatten, het tweede enkel lijnen met een hoofdletter \emph{E}. Je kan die hoofdlettergevoeligheid uitzetten met de \verb!-i! optie: \verb!egrep -i 'e'! zal zowel de hoofdletter als kleine letter \emph{e} matchen.

Tot slot kan je \verb!egrep! ook gebruiken om de zoekpatronen te \emph{inverteren}: met de \verb!-v! optie (inVert), inverteer je het zoekpatroon: \verb!egrep! zal dan enkel de lijnen uitprinten die \emph{ni\'et} voldoen aan het zoekpatroon.

\textbf{Oefeningen} Op Dodona kan je hierover enkele extra oefeningen vinden! Ik zou aanraden om deze zeker te maken.

\part{Week 2}

\chapter{Redirects}

Vorige week hebben we gezien hoe we tekstoperaties konden doen op bestanden.
Deze waren reeds nuttig afzonderlijk, maar deze week gaan we zien hoe ze veel
nuttiger te maken: we gaan de uitvoer van programma's opvangen en daar
allerhande dingen mee doen.

Zoals het je vorige week misschien is opgevallen, kunnen sommige commando's veel
uitvoer op het scherm genereren. Dit is niet overzichtelijk bepaald
overzichtelijk, en moeilijk te doorzoeken. Om op gemakkelijkere wijze iets met
deze uitvoer te kunnen doen, gaan we beginnen met de uitvoer te
\emph{redirecten} naar een bestand. De meest simpele manier om dit te doen, is
door een groter-dan teken te plaatsen na het commando, gevolgd door een
bestandsnaam waar de uitvoer naar geschreven moet worden. Bijvoorbeeld:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd > bestand.txt
\end{verbatim}

maakt het bestand \verb!bestand.txt! aan in de huidige directory (in dit geval:
de home-directory), met daarin de uitvoer van het \verb!egrep!-commando.

Probeer zelf eens de uitvoer van een van je commando's van vorige week naar een
bestand te schrijven.

Natuurlijk rijst dan de vraag: wat gebeurt er als je de uitvoer redirect naar
een bestand dat reeds bestaat? Dit bestand wordt dan \emph{overschreven}. Wil je
dat de uitvoer van een programma achteraan een reeds bestaand bestand wordt
toegevoegd (\emph{appended}), dan gebruik je een dubbele groter-dan:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd >> bestand.txt
\end{verbatim}

zal de uitvoer van het \verb!egrep!-commando \emph{achteraan toevoegen} aan
\verb!bestand.txt!.

Zoals je misschien weet, kunnen programma's uitvoer wegschrijven via
verschillende soorten \emph{(output)streams}, die onafhankelijk zijn van elkaar.
Het gaat hier over \emph{standard output} (in Python is dit waar je standaard
impliciet naar schrijft via \verb!print()!, of expliciet naar schrijft via
\verb!sys.stdout!; in Java is dit \verb!System.out!), en \emph{standard error}
(in Python is dit \verb!sys.stderr!, in Java is dit \verb!System.err!). De
eerste stream dient om normale uitvoer naar te schrijven, de tweede dient om
alle informatie over fouten naar toe te schrijven.

Het redirecten van uitvoer met een (enkele of dubbele) groter-dan zoals
hierboven slaat énkel op standard output. Fouten zullen dus niet geredirect
worden naar een bestand, maar nog altijd op het scherm verschijnen:

\begin{verbatim}
student@student-VirtualBox:~$ ls /dit/bestand/bestaat/niet > bestand.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ cat bestand.txt
student@student-VirtualBox:~$
\end{verbatim}

Wil je énkel standard error redirecten, dan doe je dit met de syntax \verb!2>!.
Als je zowel standard output als standard error wil redirecten naar eenzelfde
bestand, dan doe je dit met de syntax \verb!&>!:

\begin{verbatim}
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet 2> error.txt
/etc/passwd
student@student-VirtualBox:~$ cat error.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet 2> error.txt > bestand.txt
student@student-VirtualBox:~$ cat bestand.txt
/etc/passwd
student@student-VirtualBox:~$ cat error.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet &> alles.txt
student@student-VirtualBox:~$ cat alles.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
/etc/passwd
\end{verbatim}

\chapter{Pijplijnen van commando's}

Veel van de Linux-tools voor tekstoperaties die we eerder gezien hebben, zoals
\verb!egrep!, kunnen die operaties niet enkel toepassen op bestanden, maar ook
op een \emph{input stream}. Door geen bestanden als argument mee te geven, gaat
zo een tool automatisch de tekstoperaties uitvoeren op de invoer uit
\emph{standard input} (en zoals altijd de uitvoer naar standard output sturen).
In het geval dat je eens een programma opstart zonder bestandsargumenten, kan je
zelf de inputstream afsluiten door \emph{Ctrl+d} in te drukken. Probeer dit zelf
eens met \verb!egrep 'Hallo'!, en dan eens zowel niet-matchende tekst als
\emph{Hallo} in te geven.

Nu je weet dat zulke tools ook een stream als invoer kunnen gebruiken, is de
logische volgende stap natuurlijk om de invoer en uitvoer van meerdere tools aan
elkaar te hangen, en er een \emph{pijplijn} van te maken. Zo kan je bijvoorbeeld
de uitvoer van een \verb!egrep!-operatie doorsturen als invoer van een
\verb!cut!-operatie. Dit doen we door middel van de vertikale streep (\verb!|!,
ook wel \emph{pipe} genoemd) tussen de operaties te zetten. Bijvoorbeeld:
\begin{verbatim}
student@student-VirtualBox:~$ egrep 'student' /etc/passwd | cut -d : -f 6
/home/student
\end{verbatim}

houdt enkel de lijnen van \verb!/etc/passwd! over die \emph{student} bevatten,
en gaat enkel die lijnen onderverdelen in kolommen (met : als delimiter), en
print daarvan de 6e kolom. Je kan je pijplijnen zo lang maken als je zelf wil.
Uiteindelijk kan je dan het eindresultaat naar een bestand wegschrijven om later
te editeren of bekijken. Een andere handige tip is om het \verb!less!-commando
de laatste stap van je pijplijn te maken: dan kan je makkelijk scrollen en
zoeken in het resultaat.

Probeer eerst zelf eens als opwarmertje om in het woordenboek dat je kan vinden
op \verb!/usr/share/dict/words! te zoeken op alle woorden die eindigen op het
suffix \emph{ily}, en pipe deze verolgens naar het \verb!less!-commando.

Op Dodona vind je nog een reeks opgaven over pijplijnen met simpele
tekstoperaties. Probeer deze op te lossen.

\chapter{Geavanceerde reguliere expressies}

Bovenop de concepten van reguliere expressies die we vorige week gezien hebben,
zijn er nog twee gerelateerde concepten die nuttig zijn in de praktijk:
backreferences en het gebruiken van reguliere expressies om tekst automatisch
aan te passen.

\section{Backreferences}

Bij backreferences ga je in je expressie expliciet vragen dat bepaalde delen van
een match op een andere plaats ook voorkomen, door naar die delen te verwijzen
in de expressie. We hebben reeds gezien dat we een groep kunnen aanmaken in een
reguliere expressie met behulp van ronde haakjes; je kan later in je expressie
verwijzen naar wat tussen die haakjes stond met behulp van de syntax  $\\n$
(waarbij $n$ aangeeft naar welke groep verwezen wordt, en er vanaf 1 gestart
wordt met tellen). Dus bijvoorbeeld, de expressie \verb!(ba)\1! zal zoeken naar
de lijnen die \emph{baba} bevatten. Natuurlijk is dit niet zo nuttig als je
enkel volledige strings matcht. Dit wordt echter veel handiger als je naar
groepen verwijst die gebruik maken van patronen. Bijvoorbeeld, \verb!egrep '(b.)\1' /usr/share/dict/words! zoekt naar alle woorden die een \emph{directe
herhaling} bevatten van de karaktersequentie \emph{b, gevolgd door gelijk welk
teken}. Dit zal dus matchen op \emph{im\textbf{bibi}ng}, maar niét op
\emph{imbibe} (het gematchte teken is immers niet hetzelfde).

Een ander voorbeeld: het patroon \verb!^([0-9]).*\1$! geeft aan dat het lijnen matcht die beginnen
met een bepaald cijfer, gevolgd door een sequentie van gelijk welk teken, en dat eindigt in hetzelfde cijfer
als het begon. Dus: \textbf{9}hallo\textbf{9} matcht wel, \textbf{9}hallo\textbf{0} matcht \emph{niet}.
Een voorbeeld met twee groepen: \verb!([aeiouy]).\1([^aeiouy])\2! is een patroon dat matcht op woorden
die ergens twee een klinker bevat, gevolgd door gelijk welk teken, gevolgd door \emph{dezelfde} klinker, gevolgd
door twee keer \emph{dezelfde} medeklinker. Dus \emph{useless} matcht, want groep 1 bevat hier de \emph{e} (die dus voorkomt zowel voor als na de \emph{l}), en groep
2 bevat hier de bevat hier de \emph{s}.

\textbf{Nuttig om weten} is dat veel programmeertalen (of hun
standaardbibliotheken) ondersteuning bieden om allerhande operaties met
reguliere expressies uit te voeren. Zo heeft Python bijvoorbeeld de
\verb!re!-module die je hiervoor kan gebruiken:
\url{https://docs.python.org/3/library/re.html}.

Op Dodona vind je een aantal oefeningen op het gebruik van zo'n backreferences,
los deze op.

\section{Stream editing met reguliere expressies}

Soms willen we bepaalde sequenties in een tekst verwijderen of veranderen.
Hierbij kunnen we gebruik maken van het \verb!sed!-commando. Dit is een vrij
krachtig commando, waarvan we \emph{enkel} de functionaliteit gaan gebruiken om
stukken tekst te matchen en veranderen met reguliere expressies. Dit werkt als
volgt: \verb!sed -E -e 's/!\emph{zoekpatroon}\verb!/!\emph{vervangpatroon}\verb!/g'!. (Met optioneel
een laatste argument dat een bestand is; indien dit niet gegeven wordt, zal het
lezen van zijn input stream.) De \verb!-e! geeft aan dat we een sed-expressie
meegeven. De \verb!-E! optie geeft aan dat we graag leesbare reguliere expressies willen.
In die expressie geeft de \verb!s! aan dat we een \emph{substitutie}
gaan doen, van het patroon tussen het de eerste en tweede slash, door het
patroon tussen de tweede en derde slash. De \verb!g! achteraan geeft aan dat dit
patroon per lijn \emph{globaal} vervangen mag worden. Indien je dit niét
meegeeft, gaat per lijn slechts de eerste match vervangen worden. Meestal wil je
echter alle voorkomens van een patroon vervangen. Bijvoorbeeld:

\begin{verbatim}
student@student-VirtualBox:~$ sed -E -e 's/:/ /g' /etc/passwd
root x 0 0 root /root /bin/bash
daemon x 1 1 daemon /usr/sbin /usr/sbin/nologin
....
student@student-VirtualBox:~$ sed -E -e 's/:/ /' /etc/passwd
root x:0:0:root:/root:/bin/bash
daemon x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...
\end{verbatim}

Ook hier wordt het nog interessanter eens je complexere expressies in je
zoekpatronen gebruikt. Bovendien kan je in je substitutie ook verwijzen naar
groepen in je zoekexpressie, om zo dingen van plaats te veranderen.
De syntax voor reguliere expressies is in \verb!sed! gelijkaardig aan die \verb!egrep!
indien je de \verb!-E! optie meegeeft aan \verb!sed!.
Bijvoorbeeld, in het bestand \verb!/etc/passwd! staan enkele lijnen waarbij de
gebruikersnaam (het veld voor de eerste \verb!:!) een streepje bevat. Willen we
nu eens dat bestand editeren zodat hetgeen voor en na het streepje staat van
plaats gewisseld wordt (zodat \verb!systemd-network! wordt omgezet in
\verb!network-systemd!, en alle andere lijnen ongewijzigd blijven), kan dit als
volgt:

\begin{verbatim}
sed -E -e 's/^systemd-([^:]+):/\1-systemd:/g' /etc/passwd
\end{verbatim}

Merk hierbij op dat (net zoals bij \verb!egrep!) een \verb!^! aan het begin van
een karakterbereik aangeeft dat dit karakterbereik ge"inverteerd moet worden:
\verb![^:]! is dus gelijk welk teken dat géén \verb!:! is.

Probeer te begrijpen hoe deze vervang-expressie werkt.

Ook hierover staan er weer wat oefeningen op Dodona (al dan niet in combinatie
met \verb!egrep!).

\chapter{Nano: Een simpele tekstverwerker op de command line}

Normaal gezien gaan jullie je bestanden editeren in een grafische
tekstverwerker, en er vervolgens acties op uitvoeren op de command line. In
sommige omstandigheden kan het echter handig zijn om een bestand te editeren
vanop de command line. Hiervoor bestaan verschillende soorten tekstverwerkers.
Deze week gaan we kennis maken met een heel eenvoudige tekstverwerker:
\verb!nano!. Je start deze editor op met \verb!nano bestand.txt!. Je kan hier
gewoon tekst in typen. Onderaan het scherm staan de acties die je kan doen, en
hoe je ze moet oproepen. Hierbij geeft een hoedje (\^) aan dat je de
\emph{Ctrl-toets} moet ingeduwd houden. Als er onderaan dus staat: \verb!^O Write Out!,
wil dit dus zeggen dat om het bestand weg te schrijven, je \emph{Ctrl+o} moet
typen. Gelijkaardig moet je \emph{Ctrl+x} intypen om de editor te verlaten.

Speel even met \verb!nano! om een klein bestandje te schrijven.


\chapter{Compileren op de command line}

\emph{Compileren} is het omzetten/vertalen van bronbestanden (geschreven in
bijvoorbeeld C) naar uitvoerbare bestanden, die zogeheten \emph{binaire code}
bevatten. Hier gaan we beknopt leren hoe C en C++-bestanden te compileren vanop
de command line. We maken hiervoor gebruik van compilers van de GNU Compiler
Collection: de C compiler \verb!gcc! en de C++ compiler \verb!g++! 

Ruw gesproken bestaat wat je vaak zou beschouwen als compileren eigenlijk
uit twee stappen: het omzetten van \emph{individuele} bronbestanden
in binaire bestanden (ook wel \emph{objectbestanden} of \emph{object files}
genoemd), en het \emph{linken} van al deze objectbestanden in één enkel
uitvoerbaar bestand. We beginne met twee C-bestanden te maken: \verb!print.c! en
\verb!main.c!. Deze hebben de volgende inhoud:

\begin{verbatim}
student@student-VirtualBox:~$ cat print.c
#include <stdio.h>
void print() { printf("Hallo iedereen!\n"); }

student@student-VirtualBox:~$ cat main.c
void print();
int main() { print(); }
\end{verbatim}

Willen we deze twee bestanden compileren en linken tot een uitvoerbaar bestand,
dan gaan we als volgt te werk. Om een bestand te compileren, gebruiken we de
optie \verb!-c! van de respectievelijke compiler (in dit geval \verb!gcc!), en
gebruiken we als argument(en) de bestanden die we willen compileren naar een
objectbestand. De compiler zal deze bestanden automatisch dezelfde naam geven
als de invoerbestanden, maar met het suffix \verb!.o! (verwijzend naar het feit
dat het een objectbestand is). Dus:

\begin{verbatim}
student@student-VirtualBox:~$ gcc -c main.c print.c 
student@student-VirtualBox:~$ ls -lh main.o print.o 
-rw-r--r-- 1 student student 1.4K Feb 18 15:56 main.o
-rw-r--r-- 1 student student 1.5K Feb 18 15:56 print.o
\end{verbatim}

Willen we deze twee bestanden nu tot een uitvoerbaar bestand combineren/linken,
volstaat het om de gebruikte compiler op te roepen, maar deze keer met
objectbestanden als argumenten. Dan moeten we niet meer aangeven dat deze
bestanden gecompileerd moeten worden. De compiler vereist nu wel een naam voor
het finale, gelinkte bestand. Deze naam stellen we manueel in met de optie
\verb!-o!. Tot slot, als je een uitvoerbaar bestand dat je zelf gecompileerd
hebt wil laten uitvoeren, kan je dit niet zomaar intypen. Je moet een
padverwijzing gebruiken die ofwel een absolute verwijzing is, ofwel begint met
een \emph{expliciete verwijzing} vanaf de huidige directory (\verb!./!) (voor de
ge"interesseerden: dit heeft te maken met de \verb!PATH! omgevingsvariabele, je
kan dit gerust eens opzoeken hoe dat werkt, maar dat valt buiten de scope van
deze korte introductie). Als we het uitvoerbaar bestand \verb!hallo! willen
noemen (op Linux gebruik je normaal gezien geen \verb!.exe!-suffix), en dan
uitvoeren, dan kan dit als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ gcc -o hallo main.o print.o
student@student-VirtualBox:~$ ./hallo 
Hallo iedereen!
\end{verbatim}

Wil je optimalisaties gebruiken, dan ga je bij het compileren de
optimalisatievlaggen moeten meegeven met \verb!-O!$n$, waarbij $n$ het verwachte
optimalisatieniveau is, want anders genereert je compiler heel ineffici"ente
code. De bestaande niveaus gaan van \verb!-O0! (geen optimalisaties, maar het
compileren gaat snel), naar \verb!-O3! (heel effici"ente code, maar het
compileren zal trager zijn bij grote codebases). Vaak wordt \verb!-O2! als
tussenweg gekozen:
\begin{verbatim}
student@student-VirtualBox:~$ gcc -O2 -c main.c print.c 
student@student-VirtualBox:~$ gcc -o hallo main.o print.o
\end{verbatim}

Voor C++-programma's is dit allemaal identiek, maar dan met \verb!g++! op beide
plaatsen, in plaats van \verb!gcc!.

\chapter{Make-files}

Voor het compileren van programma's op Linux-achtige systemen wil de doorsnee
gebruiker niet alle stappen elke keer alle stappen manueel opnieuw uitvoeren.
Enerzijds wil je namelijk een scriptje dat voor jou alle compilatiestappen
uitvoert, en anderzijds wil je niet elke keer \emph{alle} bronbestanden
hercompileren als je slechts er slechts één van aangepast hebt. Om deze
problemen op te lossen, werden \emph{Makefiles} uitgevonden. Deze bestanden
hebben doorgaans als bestandsnaam \verb!Makefile!, en bevatten een reeks regels.
Elk zo'n regel beschrijft een \emph{doelbestand}, de verschillende acties die
nodig zijn om dat doelbestand te genereren, en de bronbestanden die nodig zijn
hiervoor. Lijnen die meteen beginnen met de naam van een bestand, gevolgd door
een \verb!:!, geven aan dat deze regels een doelbestand defini"eren. Na de
\verb!:! komt dan een lijst van bestanden (dit kunnen zowel bronbestanden als
intermediaire bestanden zijn) die nodig zijn om dit doelbestand te genereren.
Alle lijnen die volgen op zo'n doelbestand-regel, en bovendien \textbf{beginnen
met een tab-karakter}, geven de acties aan die nodig zijn voor het genereren.
Finaal wil je dan die makefile gebruiken met het \verb!make!-commando om de
regels te triggeren om je doelbestand te genereren. Het \verb!make!-commando
gaat dan automatisch de afhankelijkheden berekenen, kijken voor welke
doelbestanden (een van) de bronbestanden meer recent gewijzigd is dan het
doelbestand zelf, en zal dan slechts enkel die regels uitvoeren. Een voorbeeld
van een makefile die hoort bij de C-bestanden van vorig hoofdstuk, zou er als
volgt kunnen uitzien:

\begin{verbatim}
student@student-VirtualBox:~$ cat Makefile
hallo: main.o print.o
        gcc -o hallo main.o print.o
main.o: main.c
        gcc -c main.c
print.o: print.c
        gcc -c print.c
\end{verbatim}
waarbij het inspringen \emph{gebeurt met een tab-karakter}. Als we even alle
reeds bestaande objectbestand en uitvoerbare bestanden weghalen, kunnen we nu
opnieuw beginnen als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ make hallo
gcc -c main.c
gcc -c print.c
gcc -o hallo main.o print.o
\end{verbatim}

Indien we nu \verb!main.c! zouden aanpassen, gaat \verb!make! niet meer
\verb!print.o! hergenereren:

\begin{verbatim}
student@student-VirtualBox:~$ make hallo 
gcc -c main.c
gcc -o hallo main.o print.o
\end{verbatim}

Indien we \emph{niets} veranderen, gaat  \verb!make! ook doorhebben dat er niets
moet veranderd worden om \verb!hallo! up to date te houden:
\begin{verbatim}
student@student-VirtualBox:~$ make hallo 
make: 'hallo' is up to date.
\end{verbatim}

Het is echter nogal saai om in een makefile altijd expliciet voor elk C-bestand
te moeten schrijven hoe je het compileert. Die gaan namelijk allicht allemaal op
dezelfde manier gecompileerd moeten worden. Gelukkig ondersteunt \verb!make! ook
regels die kunnen matchen op een patroon in een bestandsnaam, en dan acties uit
te voeren die gebaseerd zijn op die patronen. Dit zou ons te ver leiden, de
ge"interesseerden kunnen hierover meer lezen in de manual op
\url{https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html}. Het
volstaat om te weten dat er voor C-files al zo'n regels impliciet actief zijn
als je ze niet zelf definieert, en dat je de compilatievlaggen (zoals het
optimalisatieniveau) kan instellen door in je makefile een
\verb!CFLAGS!-variabele toe te wijzen. Een meer flexibele versie van onze
bovenstaande makefile ziet er dan ook als volgt uit:

\begin{verbatim}
student@student-VirtualBox:~$ cat Makefile 
CFLAGS=-O2
hallo: main.o print.o
        gcc -o hallo main.o print.o
student@student-VirtualBox:~$ rm main.o print.o hallo 
student@student-VirtualBox:~$ make
cc -O2   -c -o main.o main.c
cc -O2   -c -o print.o print.c
gcc -o hallo main.o print.o
\end{verbatim}

Tot slot is het ook handig om weten dat voor echt grote projecten, met complexe
afhankelijkheden, makefiles zelf schrijven op een platformonafhankelijke en
configureerbare manier sterk afgeraden wordt. Tegenwoordig gebruikt men vaak
tools die, gebaseerd op een high-level beschrijving en handig configureerbare
instellingen voor jou zelf (complexe) makefiles genereren. Een tool die vaak
gebruikt wordt hiervoor is \emph{CMake}, dat je kan vinden op
\url{https://cmake.org/}.

\chapter{Administratietaken op Linux}

Veel Linux-distributies komen met een grote verscheidenheid aan
softwarepakketten die je makkelijk kan installeren. Debian-gebaseerde systemen
(zoals het systeem op de VM) maken hiervoor gebruik van het \verb!apt!-commando.
Met die tool kan je door de verschillende installeerbare pakketten zoeken, ze
installeren, etc. Debian-gebaseerde systemen bieden voor die taken ook de
(onderliggende, ietwat diepgaandere) commando's \verb!apt-get! en
\verb!apt-cache! aan, die je misschien soms ook in on-line manuals zal
tegenkomen. Wij zullen het hier echter op \verb!apt! houden.

Zoeken naar pakketten doe je met \verb!apt search! \emph{keywords}. Stel dat je
weet dat er een pakket is met een tool die allerhande bewerkingen met het
klembord (\emph{clipboard}) toestaat. Dan kan je naar dit pakket zoeken als
volgt:
\begin{verbatim}
student@student-VirtualBox:~$ apt search clipboard tool
Sorting... Done
Full Text Search... Done
deepin-picker/testing 1.6.4-1 amd64
  Color picker tool for deepin

....
....

xsel/testing,now 1.2.0+git9bfc13d.20180109-1 amd64 [installed,automatic]
  command-line tool to access X clipboard and selection buffers
\end{verbatim}

Wil je een uitgebreidere beschrijving van een pakket waarvan je de naam weet,
kan je die verkrijgen met \verb!apt show! \emph{pakketnaam}:

\begin{verbatim}
student@student-VirtualBox:~$ apt show xsel
...
Description: command-line tool to access X clipboard and selection buffers
 XSel is a command-line program for getting and setting the contents of
 the X selection.  It can also append and have it follow a growing file
 (similar to tail -f).
...
\end{verbatim}

Paketten installeren doe je met \verb!apt install! \emph{pakketnaam}.

\textbf{Opgelet}: pakketten moet je installeren als de administrator, niet als
gewone gebruiker. Totnogtoe hebben we alles als de gewone
\verb!student!-gebruiker kunnen doen. Nu volstaat dit niet, en zullen we deze
taken moeten uitvoeren als administrator. Die gebruiker heet onder
Linux-systemen de \verb!root!-gebruiker (vroeger ook wel
\textbf{s}uper\textbf{u}ser). Om een commando als \verb!root! uit te voeren
gebruik je het \verb!sudo!-commando. Dit commando kan je gebruiken om andere
commando's uit te voeren onder het account van een andere gebruiker (standaard
is dit als \verb!root!), mits je eigenlijke account daar de juiste privileges
voor hebt. Je moet dan, voor de veiligheid, eerst nog eens het wachtwoord van
jezelf ingeven:

\begin{verbatim}
student@student-VirtualBox:~$ sudo apt install xsel
[sudo] password for student: 
....
\end{verbatim}

Wil je de lijst paketten bijwerken met de meest actuele versies, dan moet je dit
doen met \verb!apt update! (als \verb!root!-gebruiker).

Indien je ooit een \verb!bash!-shell zou willen opstarten als
\verb!root!-gebruiker, dan doe je dit met \verb!sudo su! (maar let dan
\emph{h\'e\'el} goed op met wat je doet, want voor je het weet heb je je systeem
om zeep geholpen \verb!:)!).

\part{Week 3}

\chapter{Processen en subshells}

\subsection{Processen in de achtergrond draaien}

Elke keer we totnogtoe een programma gestart hebben op de command line, nam dit
programma onze terminal over: ofwel opdat we er invoer aan konden geven (zoals
een enkele \verb!egrep 'Hallo'! zonder een bestandsnaam als argument, waarna we
het programma afsloten met \verb!Ctrl+D!), ofwel opdat we de hele uitvoer van
het programma konden zien (bijvoorbeeld omdat we ergens ge"interesseerd waren
in de uitvoer van bijvoorbeeld \verb!egrep!), ofwel een combinatie van beiden.
Steeds wordt er een programma (of een keten van programma's, in het geval van
een pipe) actief die de invoer overnemen tot het programma weer afgesloten is.
Meestal is dit handig, maar niet altijd. Stel je bijvoorbeeld voor dat je een
simpele \emph{grafische} tekstverwerker in de command line wil opstarten, zoals
bijvoorbeeld de \emph{Kate} editor:
\begin{verbatim}
student@student-VirtualBox:~$ kate
\end{verbatim}

Als we Kate op deze manier opstarten, wordt onze toetsenbordinvoer van de
command line naar Kate doorgestuurd, en krijgen we op de command line de
tekstuele uitvoer van Kate te zien. Maar Kate is volledig grafisch; dat heeft
geen (voor ons relevante) uitvoer, en verwacht ook geen invoer. Dit zou willen
zeggen dat om verdere commando's in deze shell uit te voeren, we zouden moeten
wachten tot Kate terug afgesloten is, alvorens we een nieuw commando kunnen
starten. Dat is niet zo handig; het zou veel handiger zijn als we Kate konden
starten, en in dezelfde shell nieuwe commando's konden ingeven terwijl Kate
blijft draaien. Gelukkig kunnen we dit doen door dit Kate-proces op de
\emph{achtergrond te laten draaien} (zodat het een \emph{achtergrondproces} of
\emph{background process} wordt). Dit doen we door op het einde van het
commando om een programma te starten, een ampersand (\verb!&!) te zetten:

\begin{verbatim}
student@student-VirtualBox:~$ kate &
[1] 29716
student@student-VirtualBox:~$ egrep "Nu kunnen we verderwerken"
\end{verbatim}

Nu, het kan zijn dat je vergeten bent om de \verb!&! te gebruiken bij het
opstarten van een proces. In dit geval kan je het huidige
\emph{voorgrondproces} (\emph{foreground process}) onderbreken (\emph{suspend})
door \emph{Ctrl+Z} in te typen. Op dat punt is het proces volledig gestopt, en
kan je ook niet meer interageren met het GUI-venster. Op dat punt kan je in je
shell het \verb!bg!-commando (\emph{\textbf{b}ack\textbf{g}round}) uitvoeren om
dit gestopte proces verder voort te zetten als een achtergrondproces en kan je
verder werken in je shell. Als je zou beslissen om dit proces toch verder in de
voorgrond te laten draaien, kan je dit ook doen door het \verb!fg!-commando
(\emph{\textbf{f}ore\textbf{g}round}) uit te voeren. (Dit zijn de belangrijkste
aspecten die je in de praktijk moet kennen van wat in het algemeen \emph{job
control} heet.)

\subsection{Command substitution}

We hebben al gezien hoe we in een shell de uitvoer van een proces aan de invoer
van een ander proces kunnen koppelen, en hoe we de verschillende output-streams
van een proces kunnen wegschrijven naar een bestand. Nu gaan we meer
geavanceerde manieren zien waarop je de uitvoer van processen kan gebruiken in
een shell.

De eerste manier is \emph{command substitution}: het opgegeven commando wordt
uitgevoerd, en de \emph{output} ervan wordt in de shell geplakt als string op
die plaats. Het commando wordt dus eigenlijk vervangen door zijn uitvoer, die
je dan op die manier kan gebruiken om als argument aan een ander commando mee
te geven. De syntax van deze constructie is \verb!$(commando)!, hoewel je soms
ook een syntax zal zien die gebruik maakt van zogenaamde backticks:
\verb!`commando`!. Het verschil tussen beide constructies kunnen jullie
opzoeken of negeren \verb!:)!. Een voorbeeld (waarbij \verb!egrep -n! er voor
zorgt dat bij elke matchende regel het \emph{regelnummer} gevolgd door een
\verb!:! wordt afgeprint voor de match; en \verb!egrep --max-count=!$N$ er voor
zorgt dat slechts de eerste $N$ matchende regels worden teruggegeven):

\begin{verbatim}
$ egrep -n --max-count=1 '^Bart' /usr/share/dict/words
1440:Bart
$ egrep -n --max-count=1 '^Bart' /usr/share/dict/words | cut -d : -f 1
1440
$ tail -n +$(egrep -n --max-count=1 '^Bart' /usr/share/dict/words | cut -d : -f 1) /usr/share/dict/words
Bart
Barth
Bartholdi
Bartholdi's
Bartholomew
...
\end{verbatim}

Wat we hierboven dus zien is dat het de pipe-sequentie met \verb!egrep! en
\verb!cut! het regelnummer print van de eerste lijn die begint met \emph{Bart},
zijnde $1440$. Door die command substitution gaan we die pipe-sequentie
uitvoeren, en het resultaat ($1440$) plakken op de plaats waar die
\verb!$(...)! staat in die regel met \verb!tail!. Wat er dus op neerkomt dat
wat uitgevoerd wordt op die laatste regel het volgende is: \verb!tail -n +1440 /usr/share/dict/words!.

\textbf{Opgelet!} Verwar deze syntax echter niet met de constructie \verb!$(( expressie ))$! die gebruikt wordt om (eenvoudige) wiskundige berekeningen uit te voeren:
\begin{verbatim}
$ tail -n $((2+1)) /usr/share/dict/words
étude
étude's
études
\end{verbatim}

\subsection{Process substitution}

Uitvoer doorsturen naar een ander commando is allemaal leuk, maar dan moet dat
commando natuurlijk wel de mogelijkheid bieden om te lezen van standard input.
Bovendien, wat als je nu om de een of andere manier de uitvoer van meerdere
\emph{verschillende} processen wil pipen als verschillende inputs van een
commando? Daarvoor kan je \emph{process substitution} gebruiken (wat helaas
nogal makkelijk om te verwarren is qua naam met de command substitution van
eerder).

Bij process substitution gaat \verb!bash! een \emph{speciaal soort bestand}
gebruiken, waarbij als een proces naar dit bestand schrijft, het
besturingssysteem deze content slechts tijdelijk in het geheugen bijhoudt tot
een ander proces deze inhoud uitleest. Het is dus een manier om expliciet
streams tussen verschillende processen op te zetten door gebruik te maken van
bestanden die zich ergens op het bestandssysteem bevinden. Dit soort bestand
wordt een \emph{named pipe} of \emph{FIFO} genoemd. (Dit kan ook gebeuren via
speciale \verb!/dev/fd!-bestanden, maar het concept blijft hetzelfde.)

De syntax om een process substitution op te zetten, waarbij een ander programma
kan \emph{lezen van} het gesubstitueerde proces is \verb!<(commando)!. Wat er
dus gaat gebeuren is dat er zo'n FIFO-bestand wordt aangemaakt, de uitvoer van
\verb!commando! wordt naar dat bestand gestreamd, en hele sequentie
\verb!<(...)! wordt in de opdracht vervangen door \emph{de naam van dat
FIFO-bestand} zodat dit gebruikt kan worden als argument.

Ik zal dit demonstreren aan de hand van het \verb!diff!-commando. \verb!diff!
wordt gebruikt om twee bestanden (of directories) die het als argument krijgt
met elkaar te vergelijken. De uitvoer geeft visueel aan hoe je het eerste
bestand kan omzetten in het tweede bestand door het weglaten/toevoegen van
lijnen: als er een \verb!+! voor een lijn staat, moet die worden toegevoegd,
als er een \verb!-! voor staat moet deze worden verwijderd, en lijnen zonder
iets voor (er staat een spatie voor zodat alles gealigneerd blijft) zijn
identiek in beide bestanden. Als er ganse stukken tekst dezelfde zijn, worden
deze geskipt (wat dan ook aangegeven wordt in de uitvoer). De syntax is
\verb!diff --unified bestand1 bestand2!, waarbij \verb!--unified! er voor zorgt
dat de uitvoer iets leesbaarder is. Bijvoorbeeld:

\begin{verbatim}
$ cat A
Bart
Bert
Femke
$ cat B
Bart
Bert
Joris
$ diff --unified A B
--- A   2019-02-24 20:44:32.443572652 +0100
+++ B   2019-02-24 20:44:37.627572780 +0100
@@ -1,3 +1,4 @@
 Bart
 Bert
-Femke
+Joris
\end{verbatim}

Dit wil dus zeggen dat, om bestand \verb!A! in \verb!B! om te zetten (bovenaan
de uitvoer staan de bestandsnamen voor de duidelijkheid vermeld), we de lijn
met \verb!Femke! moeten verwijderen en vervangen met \verb!Joris!.

Als we nu de \emph{uitvoer van twee programma's met elkaar willen vergelijken},
kunnen we dit dus doen met process substitution:
\begin{verbatim}
$ diff --unified <(commando 1) <(commando 2)
\end{verbatim}

Een beetje een geforceerd voorbeeld, waarbij je wil weten wat het verschil is
tussen twee \verb!egrep!-commando's:

\begin{verbatim}
$ diff --unified <(egrep '^B.$' /usr/share/dict/words) <(egrep -i '^B.$' /usr/share/dict/words)
--- /dev/fd/63  2019-02-24 20:55:17.191588630 +0100
+++ /dev/fd/62  2019-02-24 20:55:17.191588630 +0100
@@ -3,3 +3,5 @@
 Bi
 Bk
 Br
+be
+by
\end{verbatim}

Hier zie je dus dat het verschil tussen een case-sensitive en case-insensitive
zoektocht naar bestanden die matchen op \verb!'^B.$'! enkel de twee woorden
\emph{be} en \emph{by} zijn. Merk dus ook op dat de `bestandsnamen' van de
argumenten die \verb!diff! bovenaan geprint heeft, de bestanden zijn die bash
aangemaakt heeft om de uitvoer van de twee subshells naar te kunnen redirecten.

In de oefeningen op Dodona vind je meer geavanceerde voorbeelden van processen
wiens uitvoer je zo nuttig met elkaar kan vergelijken.

(Het is hier misschien leuk om weten dat process substitution en redirects nog
krachtiger zijn dan wat jullie gezien hebben: process substitution kan ook
gebruikt worden om naar te schrijven, je kan werken met meerdere streams om
output te redirecten naar files, zulke streams dupliceren, inputstreams
redirecten---al dan niet om van een bestand te lezen---, etc. Dat alles zou ons
veel te ver leiden, maar zoek het gerust op als je dat meer zou interesseren!)

\chapter{Remote shell}

Een van de voordelen van de tekstgebaseerde interface die een Linux-shell
aanbiedt, is dat je op deze manier vrij makkelijk programma's kan uitvoeren,
systemen kan beheren, en taken kan automatiseren vanop afstand. De meeste
Linux-systemen draaien een server-programma waarop je kan inloggen vanop de
command line, om dan op dat (remote) systeem ook commando's uit te voeren. De
shell die je op zo'n systeem draait, wordt ook wel eens een \emph{remote shell}
genoemd; het protocol dat je hiervoor gebruikt is het \emph{ssh-protocol} (wat
voor \emph{\textbf{s}ecure \textbf{sh}ell} staat), en het commando dat je
hiervoor moet gebruiken is dan ook het \verb!ssh!-commando. Zoals gebruikelijk
heeft dit een hele boel verschillende opties, maar het belangrijkste argument
heeft de vorm \emph{gebruikersnaam}\verb!@!\emph{hostnaam}.

Om hier wat mee te oefenen, heeft de UGent een ssh-server draaien waar
studenten mee kunnen connecteren. Deze server heet \emph{helios}, en is enkel
beschikbaar via UGentNet (dus vanaf de PCs in de PC-klassen kan je hier mee
verbinden, net zoals vanop je laptop als je via eduroam verbonden bent; van
thuis zal je hiervoor de UGent-VPN moeten gebruiken). Eerst moet je er voor
zorgen dat je \mbox{(UGent-)account} actief is op dit systeem. Dit doe je via
(op UGentNet) te surfen naar \url{https://gaia.ugent.be/helios/account.cgi} en
je daar te registreren (waarna het blijkbaar tot 10 minuten kan duren eer je
account actief is).

Om dan te connecteren naar die server, gebruik je \verb!ssh !\emph{ugent-gebruikersnaam}\verb!@helios.ugent.be!. In mijn geval ziet dit er als volgt uit:
\begin{verbatim}
student@student-VirtualBox:~$ ssh bcoppens@helios.ugent.be
The authenticity of host 'helios.ugent.be (157.193.40.2)' can't be established.
RSA key fingerprint is e8:26:10:9c:07:44:e4:d4:bb:89:29:fd:3d:8c:7c:d9.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'helios.ugent.be,157.193.40.2' (RSA) to the list of known hosts.
bcoppens@helios.ugent.be's password:
Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.15.0-45-generic x86_64)
....
Last login: Sat Feb 16 13:14:35 2019 from 157.193.213.43
~ [1]$
\end{verbatim}

Hier kan je de verschillende stappen zien:
\begin{itemize}
\item ssh probeert cryptografisch te verifi"eren dat de server waarmee je
  probeert te verbinden, de server is die je verwacht (door te kijken of dit
    dezelfde server is waarmee je voorheen al verbinding had). De eerste keer
    weet ssh echter nog niet of dit al dan niet de juiste server is; je wordt
    dan expliciet gevraagd om dit zelf te checken aan de hand van de gegeven
    \emph{fingerprint}. Als je het risico laag inschat dat iemand jouw
    connectie zou onderscheppen op exact die allereerste keer je verbindt, of
    als je lui bent (of als de systeembeheerder van deze machine je die
    fingerprint niet op voorhand gegeven heeft), kan je dit negeren en gewoon
    meteen \verb!yes! intypen. Let wel op: ssh zal de volgende keren effectief
    eisen dat de server cryptografisch kan garanderen dat deze dezelfde is als
    degene waarmee je de eerste keer verbond, en zal ook weigeren verder te
    gaan indien dit niet het geval is.

\item Er wordt gevraagd naar je wachtwoord (in dit geval is dit je UGent-wachtwoord).

\item Als je je wachtwoord intypt, \emph{wordt er niets naar het scherm
  geprint!} Dus in tegenstelling tot wat je misschien verwacht, zal je géén
    sterretjes of bolletjes of wat dan ook zien verschijnen.

\item De prompt die je krijgt, ziet er als volgt uit: \verb!~ [1]$!, en niét,
  zoals je wellicht had verwacht, \verb!bcoppens@helios:~$!. Dit is omdat er
    een andere shell gebruikt wordt dan degene die we totnogtoe gebruikt
    hebben. Er zijn immers vele verschillende shell-programma's, elk met hun
    eigen set van features, en hun eigen manier van hoe je er als gebruiker
    exact mee interageert (verschillende shells hebben bijvoorbeeld
    verschillende systemen van hoe tab-completion werkt). De shell die wij
    totnogtoe gebruikt hebben is de \verb!bash!-shell (dit is een
    vaak-voorkomende shell die op de meeste systemen wel ge"installeerd is).
    Andere shells zijn bijvoorbeeld de \verb!zsh!-shell, de \verb!ksh!-shell
    (dit is de shell die standaard start op Helios), etc. Wil je in de
    vertrouwde \verb!bash!-shell terechtkomen, kan je deze simpelweg opstarten
    door \verb!bash! uit te voeren.
\end{itemize}

Kijk als voorbeeld bijvoorbeeld eens naar hoe groot de schijven zijn die in
Helios zitten.

Om een terminal (zoals een remote terminal of een terminal-in-een-terminal) af
te sluiten, kan je ofwel gewoon \verb!exit! typen, ofwel de invoer van de shell
afsluiten door \emph{Ctrl+D} te typen (wat net hetzelfde is als toen we de
invoer afgesloten hebben toen \verb!egrep! de door jou ingetypte tekst in de
terminal aan het filteren was).

Het gebruik van ssh kan trouwens ook handig zijn als je thuis bijvoorbeeld een
Raspberry Pi zou liggen hebben die Linux draait: deze kan je dan ook proberen
bedienen en configureren via ssh, in plaats van via een toetsenbord en scherm.

\chapter{Bestanden zoeken en verwerken}

Soms willen we een bepaalde actie toepassen op een aantal verschillende
bestanden. We kunnen zoals hierboven altijd manueel deze bestanden opgeven als
argument aan het eerste commando. Soms weet je echter op voorhand niet welke
bestanden dit allemaal zijn. Bijvoorbeeld wil je alle bestanden die eindigen op
\verb!.backup! verwijderen met het \verb!rm!-commando.

De eerste stap hierbij is een commando dat bestanden oplijst en filtert. Dit
kan je doen met het \verb!find!-commando: in zijn meest simpele vorm gaat dit
recursief alle bestanden en subdirectories afprinten die te vinden zijn in het
argument. Probeer eens te kijken wat het verschil is tussen de uitvoer van
\verb!ls /dev/! en \verb!find /dev/!.

Het \verb!find!-commando ondersteunt veel opties. De eerste die we gaan
gebruiken is die om enkel bestanden uit te printen die een bepaald patroon
matchen: \verb!-iregex! \emph{patroon} (de \verb!i! staat hier voor het feit
dat het een case-insensitive zoekopdracht is). Het patroon moet hierbij matchen
op \emph{het hele pad}. Bijvoorbeeld \verb!find . -iregex '.*[0-9]\.pdf'! zal
alle bestanden uitprinten die eindigen op een cijfer gevolgd door \verb!.pdf!.
Merk hierbij dus wel op dat, 1) het pad dat je doorzoekt \emph{vóór} het
zoekargument staat, en 2) omdat de expressie het hele pad moet matchen, je moet
beginnen met \verb!.*!. (Er bestaat ook een iéts simpeler manier om te zoeken,
waar je géén reguliere expressies gebruikt: \verb!-name!, maar \verb!-iregex!
is krachtiger en zo kan je je kennis over reguliere expressies ook hier
toepassen.)

\verb!find! heeft een héél uitgebreide repertoire aan filters waarop je de
bestanden kan selecteren. Om er slechts enkele te noemen: je kan enkel
uitvoerbare bestanden oplijsten, enkel bestanden oplijsten die recenter
gewijzigd zijn dan een opgegeven tijd, enkel bestanden die groter of kleiner
zijn dan een bepaalde grootte, etc. Die filters kan je bovendien ook met elkaar
combineren. Meer info hierover kan je vinden in de man-page van \verb!find!
onder de sectie \emph{TESTS}; de man-page heeft ook een uitgebreide lijst
voorbeelden onderaan staan.

Bovendien ondersteunt \verb!find! ook een hele hoop \emph{acties} die kunnen
uitgevoerd worden voor elk bestand dat voldoet aan de zoekfilter. Standaard
gebruikt \verb!find! de actie die alle geselecteerde bestanden gewoon uitprint
naar het scherm (dit is de \verb!-print! actie). Willen we een bepaald commando
oproepen voor elk bestand dat we gevonden hebben, gebruiken we het argument
\verb!-execdir! als volgt: \verb!-execdir ... {} ... \;'!, waarbij het commando
start met het eerste wat volgt op de \verb!-execdir!, en waarbij de \verb!{}!
vervangen wordt door de bestandsnaam. Het commando eindigt op de plaats van de
\verb!\;!. (Technisch gezien moet het commando eindigen op een \verb!;!, maar
de shell interpreteert een \verb!;! standaard als het einde van een commando,
en niet als een argument. Daarom moet je het escapen met een \verb!\!.) Het
commando wordt opgestart in de directory waar het gevonden bestand zich
bevindt.

Bijvoorbeeld:
\begin{verbatim}
$ find /bin/ -iregex '.*less'
/bin/zless
/bin/bzless
/bin/less
$ find /bin/ -iregex '.*less' -execdir diff {} /bin/bash \;
Binary files ./zless and /bin/bash differ
Binary files ./bzless and /bin/bash differ
Binary files ./less and /bin/bash differ
\end{verbatim}
Bij de eerste invocatie van \verb!find! gaan we zoeken naar alle bestanden die
ergens te vinden zijn in \verb!/bin/! die eindigen op \verb!less!, en deze
gewoon printen naar het scherm (in mijn geval zijn dit dus 3 bestanden). Bij de
tweede invocatie, gaan we elk van deze gevonden bestanden vergelijken met het
(binaire) bestand \verb!/bin/bash!, en meer specifiek gaan we elk van deze
bestanden opgeven als éérste argument van het \verb!diff!-commando. Het
uitgevoerde commando wordt dan \verb!diff !\emph{gevonden bestand}\verb! /bin/bash!,
voor élk van de gevonden bestanden.

\chapter{Scripting}
Met de shell kan je ook taken automatiseren, en dus met andere woorden (kleine) programma's schrijven. Dit wordt ook wel \emph{shell scripting} genoemd. Om programma's te schrijven hebben we wel enkele extra concepten nodig: variabelen en controlestructuren. 

Een variabele ken je een waarde toe met de syntax \verb!VARIABELE='waarde'!. (Variabelen gaan we meestal in allemaal hoofdletters schrijven voor de duidelijkheid.) Je kan de waarde van een variabele elders gebruiken door er als volgt naar te verwijzen: \verb!${VARIABELE}!. Bijvoorbeeld:

\begin{verbatim}
$ BESTAND='/bin/bash'
$ ls -lh ${BESTAND}
-rwxr-xr-x 1 root root 1.2M Jan 14 16:27 /bin/bash
\end{verbatim}

We kunnen de waarde van een variabele naar het scherm printen met behulp van het \verb!echo!-commando. Dit commando gaat al zijn argumenten printen naar het scherm; dus ook enige variabelen die het als argument meekrijgt:
\begin{verbatim}
$ BESTAND='/bin/bash'
$ echo Het bestand is ${BESTAND}
Het bestand is /bin/bash
\end{verbatim}

Soms ga je willen dat een variabele deel uitmaakt van een groter, langer argument (al dan niet met spaties). Totnogtoe hebben we lange argumenten (met bijvoorbeeld spaties in) aangegeven door het tussen enkele quotes te zetten. We kunnen iets gelijkaardigs willen, maar dan met variabelen. Dit kan echter niet zomaar: als je in de shell iets tussen enkele quotes zet, gaan variabelen niet vervangen worden door hun waarde. Als je wil dat de variabele effectief vervangen wordt, dan zet je dit argument tussen dubbele quotes (\verb!"!). Je kan het verschil makkelijk zien in het volgende voorbeeld:

\begin{verbatim}
$ BESTAND='/bin/bash'
$ echo 'Deze hele string is een enkel argument, en het bestand is ${BESTAND}'
Deze hele string is een enkel argument, en het bestand is ${BESTAND}
$ echo "Deze hele string is een enkel argument, en het bestand is ${BESTAND}"
Deze hele string is een enkel argument, en het bestand is /bin/bash
\end{verbatim}

In de shell zijn al standaard een aantal (omgevings)variabelen gedefinieerd. Degene die je allicht het `meest' zal gebruikt zien (wat nog altijd heel zelden zal zijn), zijn de \verb!${USER}!-variabele die de naam van de huidige gebruiker bevat, en de \verb!${PWD}!-variabele die de huidige directory bevat.




\textbf{Side-note: zetten bij find} Ctrl+R


\chapter{\texttt{vim}: een geavanceerde teksverwerker op de command line}

vimdiff

\chapter{Versiecontrole met git}

\chapter{Parting words}

TODO TODO: ps?

portability naar andere shells, cheat sheets, ...?

\end{document}
