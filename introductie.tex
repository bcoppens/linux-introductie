\documentclass[a4paper,twoside,openany]{memoir}
\usepackage[dutch]{babel}
\usepackage{hyperref}
\usepackage{fullpage}

\epigraphfontsize{\small\itshape}
\setlength\epigraphwidth{8cm}
\setlength\epigraphrule{0pt}

\begin{document}

\epigraphfontsize{\small\itshape}

\chapter{Inleiding tot Linux}
\epigraph{``It’s a Unix system, I know this!''}{--- \textup{Lex Murphy}, Jurassic Park}

De komende drie weken gaan we een korte inleiding geven tot Linux. Maar wat is
Linux? Strikt genomen is Linux niet meer dan een \emph{operating system kernel}:
deze zorgt er achter de schermen voor dat je verschillende applicaties kan
starten en tegelijkertijd laten draaien, dat de invoer die je via een
toetsenbord ingeeft bij de applicaties toekomt, dat deze applicaties' iets op
het scherm kunnen printen als uitvoer, etc. Een gebruiker interageert echter
niet direct met de (Linux-)kernel, maar eerder met applicaties die als interface
dienen. Meestal voorzien deze applicaties een grafische interface: je bent dit
wel gewend uit Windows en OS X, en deze interfaces bestaan ook onder Linux,
zoals KDE en Gnome. Grafische, intuïtieve, interfaces zijn echter pas redelijk
laat in gebruik genomen. Voorafgaand de opkomst van de grafische interface aan
was er een andere interface die de computerwereld domineerde: de
\emph{command-line} interface.

Deze inleidende sessies gaan over de command-line interface (of
\emph{commandolijninterface}. Deze is  helaas (veel) minder intuïtief, maar
daarom niet minder belangrijk is om wat ervaring mee te hebben. Met enige kennis
van de command-line applicaties, en hoe je die kan combineren met elkaar, kan je
je leven later (hopelijk) veel makkelijker maken (en dat niet alleen in de
eigenlijke practica van \emph{computerarchitectuur}, maar ook in andere vakken
van de opleidingen computerwetenschappen en elektrotechniek, en misschien zelfs
je thesis). Een grote sterkte van de command line op Linux (die voortvloeit uit
een rijke traditie van command line interfaces die ontstaan is in de jaren '70
en '80 en ontwikkeld werden voor Unix-systemen), is dat deze het zeer eenvoudig
maken om zeer complexe tekstoperaties en bestandssysteemoperaties met elkaar te
combineren. De uitvoer van veel programma's is simpelweg tekst, wat het
uitermate handig maakt om de uitvoer van programma's te filteren, combineren,
etc. Bij wijze van voorbeeld: je kan alle PDF-bestanden zoeken op je systeem, en
die dan filteren op degenen die de tekst \emph{``Voorstel tot het bevriezen van
$n$ postgraduaatsopleidingen''} bevatten, waarbij $n$ gelijk welk natuurlijk
getal is; je kan de uitvoer van een simulator zo herstructureren dat je de
interessante data rechtstreeks in een spreadsheet kan plakken, etc.

\section{Organisatie van de sessies}

Deze inleidende sessies gaan door tijdens de eerste drie lesweken, elke dinsdag
van 8u30 tot 9u40, in PC-klassen A en B in de Plateau. Je gaat hier op twee
manieren met Linux leren werken:

\begin{enumerate}

  \item Met enkele oefeningen op Dodona. Deze oefeningen zullen gradueel
    beschikbaar gemaakt worden op de Dodona-site die je kan vinden op
    \url{https://dodona.ugent.be/nl/courses/79/}.

  \item Door te oefenen op een virtueel Linux-systeem dat jullie in VirtualBox
    zullen opzetten. Installeer hiervoor eerst VirtualBox
    (\url{https://www.virtualbox.org/}), end download onze image op
    \url{https://users.elis.ugent.be/~bcoppens/kubuntu-computerarchitectuur.7z}.
    \textbf{Gelieve deze stappen reeds op voorhand te voltooien zodat we hier
    tijdens de labo's zelf niet te veel tijd aan verliezen.} Indien je wil
    werken op een PC in de practicumzaal, zet dan best de (gedecomprimeerde)
    image al op een USB stick. Op dit Linux-systeem hebben we voor jullie al
    een gebruiker \emph{student} aangemaakt wiens \textbf{wachtwoord} ook
    simpelweg \emph{student} is.

\end{enumerate}

De structuur van de sessies zal er als volgt uitzien (voorlopige planning, onder voorbehoud):

\begin{itemize}

  \item \emph{Week 1}: Inleiding tot de command line, de meest simpele
    bestandssysteemoperaties, eenvoudige tekstoperaties, en \emph{reguliere
    expressies}.

  \item \emph{Week 2}: Het combineren van verschillende operaties tot veel
    krachtigere en complexere pijplijnen aan de hand van \emph{pipes} en
    \emph{redirects}, geavanceerdere reguliere expressies, en hoe simpele
    C(++)-programma's te compileren vanaf de command line.

  \item \emph{Week 3}: Meer geavanceerde toepassingen van de concepten van de
    eerste twee weken, Linux-systemen op het internet beheren met een
    \emph{remote shell}, en een korte introductie tot \emph{git}.

\end{itemize}

Het materiaal behorende tot weken 2 en 3 zal voor die lessen online komen. \textbf{Deze handleiding zal dus ook nog twee keer aangepast worden met het nu nog ontbrekende materiaal van weken 2 en 3!}

\part{Week 1}
\chapter{Inleiding tot de command line}

Start in je Linux virtuele machine een console-\emph{terminal} op door het programma \emph{Konsole} te starten. (Zoals zo vaak in de Linux-wereld zijn er duizend-en-\`e\`en verschillende terminals beschikbaar, waarvan Konsole er slechts een is.) Eerst gaat dit wat uitvoer produceren die je voorlopig mag negeren (er start namelijk een programma dat automatisch de meest recente opgaves op je systeem zal downloaden). Na even te wachten, zal je dan je \emph{prompt} te zien krijgen:

\begin{verbatim}
student@student-VirtualBox:~$ 
\end{verbatim}

Dit is waar je je commando's zal intypen. Wat wil die tekst nu zeggen? Dit wil zeggen dat in deze sessie je op het systeem genaamd \emph{student-VirtualBox} aan het werken bent (later zullen we ook nog op een ander systeem inloggen met een andere naam) als gebruiker \emph{student}. (De gebruikersnaam vind je voor de \texttt{@}, de naam van het systeem na de \texttt{@}). Wat er tussen de \texttt{:} en de \texttt{\$} staat, is de \emph{directory} waar je je op dit moment bevindt. Standaard zal een console-sessie vaak starten in de \emph{home-directory} van de ingelogde gebruiker; deze wordt vaak afgekort als \texttt{\~}.

Om te weten waar deze afkorting voor staat, gaan we het eerste commando intypen, \verb!pwd! (\emph{Print Working Directory}):
\begin{verbatim}
student@student-VirtualBox:~$ pwd
/home/student
\end{verbatim}

In de loop van deze sessies zal je nog veel meer van deze commando's tegenkomen met enigszinds obscure namen, die bovendien vaak nog meer obscure manieren hebben om opties mee te geven. Dit probleem wordt een beetje gecompenseerd door de ingebouwde handleiding (\emph{manuals}, \emph{man-pages}). Je kan die opvragen met het commando \verb!man!. Stel je voor dat je je afvraagt wat de opties zijn van het \verb!ls!-commando dat we zometeen gaan zien. Dan type je:
\begin{verbatim}
student@student-VirtualBox:~$ man ls
\end{verbatim}
waarna je in een zeer simpele textviewer terecht komt met de handleiding van het \verb!ls!-commando. Helemaal bovenaan staan heel summiere uitleg van wat het programma doet, een summier overzicht van de mogelijke opties, gevolgd door een heel uitgebereide beschrijving van al die opties, eventueel gevolgd door voorbeelden en aandachtspunten. Hoe gebruik je die viewer nu?
\begin{itemize}
\item \emph{Scrollen} door de tekst kan je met de pijltjes omhoog en omlaag, en door PageUp en PageDown.
\item \emph{Zoeken} door de tekst, kan je door forward slash (`/') te typen, gevolgd door je zoekterm (bijvoorbeeld in het geval van \verb!ls!, als je wil weten hoe de uitvoer gesorteerd kan worden, kan je `sort' typen), en dan op \emph{enter} duwen. Alle hits op die zoekterm zullen oplichten in de tekst, en de viewer springt automatisch naar de eerste hit. Je kan bovendien eenvoudig naar de volgende/vorige hit in de tekst gaan met respectievelijk de toetsen `n' (\emph{next}) en `p' (\emph{previous}).
\item {Afsluiten} van de viewer kan je doen door de `q'-toets (\emph{quit}).
\end{itemize}

\chapter{Simpele bestandssysteemoperaties}

We gaan een aantal heel simpele bestandssysteemoperaties bekijken. Vergeet niet dat je meer details hierover (zoals extra opties) kan opzoeken in de relevante man-pages.

\section{\texttt{ls} --- List Files/Directory Contents}

Het \verb!ls!-commando laat toe om de inhoud van een directory te bekijken, en om details van bestanden weer te geven. Als je geen specifieke bestanden of directories (directories kan je eigenlijk beschouwen als bestanden) meegeeft als argument, dan zal het informatie uitprinten over de huidige directory. Standaard zal het \emph{\`enkel} de lijst bestanden (en dus ook directories) uitprinten:

\begin{verbatim}
student@student-VirtualBox:~$ ls
computerarchitectuur_practica Desktop Documents Downloads Music Pictures Public
Templates Videos
\end{verbatim}

Dit wil dus zeggen dat in je home-directory 9 bestanden (in dit geval dus allen directories) bevat.

Standaard zijn alle verwijzingen naar bestanden \emph{relatief ten opzichte van de huidige directory}. Dus als je weet dat je in de home-directory zit, en dat die directory een (sub)directory \verb!computerarchitectuur_practica! bevat, kan je de bestanden in die (sub)directory als volgt printen: \verb!ls computerarchitectuur_practica!.

Directories en bestanden daarin worden van elkaar gescheiden door een forward slash (/). Dus, nu je weet dat in die directory een subdirectory \verb!pract01! zit, kan je die inhoud als volgt laten zien door het commando  \verb!ls computerarchitectuur_practica/pract01! te typen.

Je kan ook werken met \emph{absolute padverwijzingen}. In Windows is dit typisch iets wat begint met \verb!C:\!. In Unix-gebaseerde systemen zoals Linux (maar ook OSX), beginnen die echter steeds met een initie"ele forward slash. Alle bestanden zijn dus te vinden via verwijzingen die starten vanaf de \emph{root-directory}, dus ook al je schijven, USB-sticks, etc., zitten in eenzelfde directorystructuur. We hebben reeds zo'n pad gezien hierboven voor de home-directory: \verb!/home/student!. Dit wil zeggen dat we starten vanaf de root-directory \verb!/!, die een subdirectory \verb!home! bevat, die dan op zijn beurt een subdirectory \verb!student! bevat.

\textbf{Belangrijke tip!} Je gaat het misschien net als ik ook al beu zijn om elke keer opnieuw \verb!computerarchitectuur_practica! voluit te typen. Dat is saai, traag, en foutgevoelig. De \emph{shell} (het programma waarmee je interageert in de terminal en die je \verb!student@student-VirtualBox:~$! print), heeft gelukkig een feature die dit probleem zo goed als volledig oplost: \emph{tab-completion}. Je typt gewoon het begin van een bestand/directory, en drukt de tab-toets in. De shell zal dan zo ver mogelijk aanvullen als hij kan, gegeven de bestanden in de directory. Dus bij \verb!computerarchitectuur_practica! weet je nu dat dit het \'enige bestand is in de home-directory dat begint met de letter \verb!c!. Dus kan je gewoon typen: \verb!ls c!\emph{tab}, waarna automatisch alles wordt aangevuld. Die directory heeft nu 8 practica-subdirectories. Dus kan je \verb!computerarchitectuur_practica/p!\emph{tab} typen, waarna dit wordt aangevuld tot \verb!computerarchitectuur_practica/pract0!. Aangezien er echter 8 verschillende subdirectories zijn, kan de shell dit uiteraard niet aanvullen tot op het einde. In dit geval is het handig om 2 keer op tab te duwen:
\verb!computerarchitectuur_practica/pract0!\emph{tab} \emph{tab}: dan laat de shell alle bestanden zien die beginnen met \verb!pract0!, zodat je makkelijk dat karakter zelf kan typen (en dan eventueel weer verder aan te laten vullen door weer op \emph{tab} te duwen).

Probeer eens op de volgende 3 manieren de inhoud van \verb!computerarchitectuur_practica! te laten zien: met een relatief pad, met een absoluut pad, en met een pad relatief ten opzichte van de shortcut voor de homedirectory \verb!~!. Maak hierbij gebruik van tab-completion.

Je kan ook meer informatie laten printen door \verb!ls!. De meest handige manier is \verb!ls -lh!, wat onder andere de grootte print van het bestand. Probeer dit eens uit met \verb!ls -lh /bin/!. Gebruik de man-page om te achterhalen wat de \verb!l! en \verb!h! opties precies betekenen. (Voor de rest is het allicht ook interessant om weten dat je kan sorteren op allerhande soorten informatie, als je meer hierover wil weten kan je dat opzoeken in de man-page.)

\section{\texttt{cd} --- Change Directory}

We weten nu dat er enerzijds een concept is van een huidige directory, en anderzijds weten we dankzij \verb!ls! welke directories er waar zijn. Met \verb!cd! kunnen we een andere directory de huidige directory maken. Bijvoorbeeld, als we naar de \verb!computerarchitectuur_practica!-directory gaan, en dan het \verb!ls!-commando uitvoeren, zal de inhoud van de \verb!computerarchitectuur_practica!-directory getoond worden:

\begin{verbatim}
student@student-VirtualBox:~$ cd computerarchitectuur_practica
student@student-VirtualBox:~/computerarchitectuur_practica$ ls
pract01 pract02 pract03 pract04 pract05 pract06 pract07
pract08 README
\end{verbatim}

Je kan hier ook meteen zien dat de prompt hier mooi aangeeft dat de huidige directory veranderd is.

Om terug te gaan naar de bovenliggende directory, kan je gebruik maken van \verb!..!, dit geeft aan dat je de verwijst naar de bovenliggende directory. Dus bijvoorbeeld:
\begin{verbatim}
student@student-VirtualBox:~/computerarchitectuur_practica$ cd ../..
student@student-VirtualBox:/home$ cd ../..
\end{verbatim}

Hier gaan we dus in de bovenliggende directory van de bovenliggende directory, wat in dit geval \verb!/home! is.

\section{\texttt{mkdir} --- Make Directory}

We kunnen directories aanmaken met het \verb!mkdir! commando: \verb!mkdir nieuwedirectory!. De verwijzing naar de nieuwe directory kan zowel relatief als absoluut zijn, maar standaard gaat het tool er van uit dat slechts te meest diepe directory moet worden aangemaakt, en alle bovenliggende directories reeds bestaan. Zoek op in de man-page hoe je \verb!mkdir! die directories ook kan laten aanmaken voor je.

\section{\texttt{cp} --- CoPy Files}

Met het \verb!cp!-commando kan je bestanden kopi"eren. Er zijn twee mogelijkheden:

\begin{itemize}
\item Het doel is een bestandsnaam: \verb!cp bestand1 bestand2! zal \verb!bestand1! kopi"eren naar een bestand met de naam \verb!bestand2!.
\item Het doel is een directory: \verb!cp bestand1 directory! zal een kopie van \verb!bestand1! aanmaken in \verb!directory!; het nieuwe bestand zal (in die directory) dezelfde naam hebben als het originele bestand. In dit geval kan je ook meerdere bestanden in 1 keer kopieren: \verb!cp bestand1 bestand2 bestand3 directory!.
\end{itemize}

Probeer eens een bestand uit de \verb!/bin!-directory te kopi"eren naar een directory die je zonet hebt aangemaakt, en verifieer dat de kopie even groot is als het origineel.

\section{\texttt{mv} --- MoVe Files}

Het \verb!mv!-commando werkt net als het \verb!cp!-commando, maar het verplaatst de bestanden in plaats van ze te kopi"eren. Volledig gelijkaardig met \verb!cp! kan het doel een bestandsnaam of een directory zijn.

\section{\texttt{rm} --- ReMove Files}

Tot slot willen we ook bestanden kunnen verwijderen. Dit kan met het \verb!rm!-commando.

\section{\texttt{cat} --- Een slechte textviewer}
Het \verb!cat!-commando gaat de bestanden die het meekrijgt als argument gewoon achter elkaar naar scherm printen. Probeer eens een bestand uit de \verb!computerarchitectuur_practica! directory op scherm te printen.

\section{\texttt{less} --- Een simpele textviewer}
Het \verb!cat!-commando is niet zo handig om tekst in te bekijken. Het zou veel handiger zijn als we de textviewer die gebruikt wordt voor de man-pages niet zouden kunnen hergebruiken. Gelukkig kunnen we die textviewer ook gewoon hergebruiken: dit is het \verb!less!-commando. Probeer met \verb!less! eens hetzelfde bestand te openen als je zonet deed met \verb!cat!.

\section{\texttt{touch} --- Een leeg bestand aanmaken}

Met het \verb!touch!-commando kan je een leeg bestand aanmaken. (Dit commando heeft eigenlijk een ander doel, zoals je kan lezen in de man-page. Maar als je het als argument een bestandsnaam geeft die nog niet bestaat, zal het dat bestand aanmaken.)

Maak in je homedirectory eens een leeg bestand \verb!A! aan. Net zoals bij de vorige commando's, kan je ook meerdere argumenten aan dit commando meegeven, elk van die bestanden zal dan worden aangemaakt.

\textbf{Belangrijk!} De verschillende argumenten van een commando worden door een spatie van elkaar gescheiden. Maar als nu een van de argumenten een bestandsnaam is die een spatie bevat, wat dan? Dan kan je dat argument tussen een koppel enkele quote-tekens (\verb!'!) zetten: alles wat daartussen staat, wordt beschouwdt als hetzelfde argument, inclusief spaties. Als we bijvoorbeeld 3 bestanden willen aanmaken, waarvan \'e\'en bestand spaties bevat, kan je dit als volgt doen.

\begin{verbatim}
student@student-VirtualBox:~$ touch bestand1 'bestandsnaam 2 met spaties' bestand3
\end{verbatim}

Probeer dit zelf eens, en kijk ook hoe dit er uit ziet met zowel \verb!ls! als \verb!ls -lh!. Probeer zo'n bestand ook eens te kopi"eren. Merk bovendien ook op dat het geen kwaad kan om ook quote-tekens te zetten rond argumenten zonder spatie:

\begin{verbatim}
student@student-VirtualBox:~$ touch 'bestand4' 'bestand5'
\end{verbatim}

zal 2 extra bestanden aanmaken, waarbij de quotes geen deel uitmaken van de bestandsnaam. Je kan in principe ook dubbele quotes (\verb!"zoals dit"!) gebruiken, maar die hebben een subtiel andere betekenis dan de enkele quote die ik hierboven demonstreerde. Het verschil zal je zien in sessie 3; gebruik tot dan voor de veiligheid gewoon de enkele quotes.

\chapter{Simpele tekstoperaties}

Nu gaan we eens iets doen met de tekstbestandjes. In deze sessie gaan we het eenvoudig houden, en gaan we gewoon de inhoud van bestanden wat doorzoeken en herordenen.

\section{\texttt{cut} --- Herordenen van kolommen}

Met het \verb!cut!-commando kan je tekstbestanden onderverdelen in kolommen, en dan een deelverzameling van die kolommen uitprinten op het scherm (in de volgorde die jij wil). De kolommen (\emph{fields}) die je wil printen, geef je aan met het argument dat volgt op \verb!-f!. Het \verb!cut!-commando verdeelt een lijn onder in verschillende kolommen afhankelijk van een \emph{delimiter}. Zoals je in de man-page al kan zien, is deze delimiter standaard een tab-karakter, wat in de praktijk nogal onhandig is; die kan je makkelijk aanpassen met \verb!-d!.

Om een simpel voorbeeld te geven, het bestand \verb!/etc/passwd! bevat informatie over de gebruikers op het systeem. De verschillende velden zijn van elkaar gescheiden door een \verb!:!-karakter. Als je dan bijvoorbeeld per gebruiker de volledige naam (het vijfde veld) en de home-directory van die gebruiker (het zesde veld) wil uitprinten, kan je dit doen als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ cut -d : -f 5,6 /etc/passwd
\end{verbatim}

Probeer eens een spatie als delimiter te gebruiken?

\chapter{Reguliere expressies}

Reguliere expressies zijn uitdrukkingen die je toestaan om simpele zoekpatronen (dit zijn dan de expressies) te beschrijven die meer zijn dan enkel letterlijke stukken tekst. Achter dit concept zit een heel interessante theoretische achtergrond, die volledig buiten de scope van dit document valt. Wat belangrijk is, is wat je er mee kan en hoe je ze opbouwt.

Je doorzoekt een of meerdere tekstbestand met een reguliere expressie als volgt: \verb!egrep '!\emph{patroon}\verb!' bestand(en)!. Dit gaat alle lijnen uitprinten in de gegeven bestanden die voldoen aan de gegeven reguliere expressie/zoekpatroon. Zo'n patroon zet je opnieuw best tussen quotes, niet alleen omdat een patroon spaties kan bevatten, maar ook omdat bepaalde zoekpatronen speciale karakters zijn in de shell, en door die in quotes te zetten verliezen ze hun speciale betekenis.

Een regulier expressie bouw je op uit kleinere sub-expressies. De belangrijkste sub-expressies en manieren om ze op te bouwen zijn:

\begin{itemize}
\item \emph{Letterlijke karakter:} Dit geef je gewoon letterlijk in.  Bijvoorbeeld: \verb!egrep 'a' bestand.txt! zoekt geeft alle lijnen die het karakter \emph{a} bevatten in het bestand \verb!bestand.txt!
\item \emph{Aan elkaar plakken van expressies (concatenation)}: door expressies achter elkaar te plakken, ga je zoeken op de regels die die opeenvolging van expressies bevatten. Zoals je weet van het vorige puntje, is een enkel karakter een expressie; je kan die dan zoals je zou verwachten achter elkaar typen om volledige zinnen te zoeken. Bijvoorbeeld, \verb!egrep 'Linux is tof' bestand.txt! zoekt op de tekst \emph{Linux is tof} (dat is dus de opeenvolging van de tekens \emph{L, i, n, etc.} in het bestand \verb!bestand.txt!.
\item \emph{Eender welk karakter:} Als je het \verb!.!-karakter in een reguliere expressie op een bepaalde plaats zet, zal gelijk welk karakter daar mogen voorkomen. Bijvoorbeeld: \verb!egrep 'm.h' bestand.txt! zal alle regels uitprinten die tekst bevatten die de vorm heeft van `m, gevolgd door gelijk welk karakter, gevolgd door h'.
\item \emph{Een bereik (range) van karakters:} soms is \verb!.! te ruim, en wil je enkel regels die op een bepaalde positie een beperkt bereik van karakters toestaan. Dit kan je doen door al die karakters tussen vierkante haakjes te zetten. Bijvoorbeeld: \verb!Bar[td]! is een patroon dat zowel \emph{Bart} als \emph{Bard} zal matchen. Als het bereik groot is, maar op elkaar volgt in de ASCII-tabel, kan je dit afkorten door een streepje: het patroon \verb![a-d]! zal \emph{a,b,c,d} matchen.
\item \emph{Een keuzemogelijkheid:} als je lijnen wil printen die een van meerdere zoekpatronen matcht, kan je die scheiden van elkaar met een vertikaal streepje, ook wel het \emph{pipe symbol} genoemd: \verb!|!. Bijvoorbeeld, \verb!Aap|Noot|Mies! zal alle lijnen printen die minstens eenmaal \emph{Aap}, \emph{Noot}, of \emph{Mies} bevatten.
\item \emph{Herhaling, 0 of meer keer:} Als je het voorgaande element 0 of meer keer wil herhalen, dan zet je hier een asterisk na: \verb!ka*t! zal zowel matchen op \emph{kt}, \emph{kat}, \emph{kaat}, etc. Dit werkt uiteraard ook op andere types referenties, \verb![0-9]*! zal matchen op gelijk welke opeenvolging van cijfers (en ook 0 cijfers).
\item \emph{Herhaling, 1 of meer keer:}, hiervoor gebruiken we een plus-teken. Dus \verb![0-9]*! zal matchen op elk getal, dat minstens uit \'e\'en cijfer bestaat.
\item \emph{Herhaling, bereik:} dit doe je met accolades en het aantal keer dat het herhaald wordt ertussen. Bijvoorbeeld, als je exact een Googol wil matchen, wat een 1 is gevolgd door 100 0'en, dan kan je dit doen als volgt: \verb!10{100}!. (Dus om precies te zijn: het element voor de accolades is een 0, en dat moet 100 keer worden herhaald.) Je kan ook een heel bereik opgeven (tussen twee getallen, ten hoogste een bepaald getal), de exacte syntax hiervan kan je in de man-page van egrep vinden.
\item \emph{Groeperen:} De bovenstaande operaties slaan steeds op het vorige \emph{element} in de expressie. Aangezien individuele karakters ook al expressies zijn, wil dit zeggen dat de expressie \verb!Noot{2}! \'enkel zal matchen op \emph{Noott} (dus een dubbele \emph{t}), maar ni\'et op \emph{NootNoot}. Om die operaties op een samenstelling van expressies te zetten, zet je die samenstelling tussen ronde haakjes. Wat tussen ronde haakjes staat, zal dan worden aanzien als een enkele expressie. Dus om \emph{NootNoot} te matchen, kan je dus de expressie \verb!(Noot){2}! gebruiken.
\item \emph{Begin van een regel:} Dit geef je aan met het teken \verb!^!. Dus \verb!^A! gaat enkel op regels matchen die beginnen met een \emph{A}.
\item \emph{Einde van een regel:} Dit geef je aan met het teken \verb!$!. Dus \verb!A$! gaat enkel op regels matchen die eindigen op een \emph{A}.
\end{itemize}

Een voorbeeldje:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd
\end{verbatim}

zal alle regels in \verb!/etc/passwd! uitprinten die eindigen op ofwel \verb!nologin! ofwel op \verb!false!. Bovendien zal de omgeving die wij gebruiken, \verb!egrep! standaard zo instellen dat de specifieke delen die gematcht worden, gekleurd worden, zodat je duidelijk kan zien waar de matchende expressies voorkomen in elke lijn.

Standaard gaat \verb!egrep! hoofdlettergevoelig zoeken. Dit wil zeggen dat \verb!egrep 'e'! niet hetzelfde is als \verb!egrep 'E'!: het eerste zal enkel lijnen weergeven die een kleine letter \emph{e} bevatten, het tweede enkel lijnen met een hoofdletter \emph{E}. Je kan die hoofdlettergevoeligheid uitzetten met de \verb!-i! optie: \verb!egrep -i 'e'! zal zowel de hoofdletter als kleine letter \emph{e} matchen.

Tot slot kan je \verb!egrep! ook gebruiken om de zoekpatronen te \emph{inverteren}: met de \verb!-v! optie (inVert), inverteer je het zoekpatroon: \verb!egrep! zal dan enkel de lijnen uitprinten die \emph{ni\'et} voldoen aan het zoekpatroon.

\part{Weken 2 en 3}
Wordt vervolgt \verb!:)!

\end{document}
