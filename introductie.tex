\documentclass[a4paper,twoside,openany]{memoir}
\usepackage[dutch]{babel}
\usepackage{hyperref}
\usepackage{fullpage}

\epigraphfontsize{\small\itshape}
\setlength\epigraphwidth{8cm}
\setlength\epigraphrule{0pt}

\begin{document}

\epigraphfontsize{\small\itshape}

\chapter{Inleiding tot Linux}
\epigraph{``It’s a Unix system, I know this!''}{--- \textup{Lex Murphy}, Jurassic Park}

De komende drie weken gaan we een korte inleiding geven tot Linux. Maar wat is
Linux? Strikt genomen is Linux niet meer dan een \emph{operating system kernel}:
deze zorgt er achter de schermen voor dat je verschillende programma's kan
starten en tegelijkertijd laten draaien, dat de invoer die je via een
toetsenbord ingeeft bij de programma's toekomt, dat deze programma's iets op
het scherm kunnen printen als uitvoer, etc. Een gebruiker interageert echter
niet direct met de (Linux-)kernel, maar eerder met programma's die als interface
dienen. Meestal voorzien deze programma's een grafische interface: je bent dit
wel gewend uit Windows en OS X, en deze interfaces bestaan ook onder Linux,
zoals KDE en Gnome. Grafische, intuïtieve, interfaces zijn echter pas redelijk
laat in gebruik genomen. Voorafgaand de opkomst van de grafische interface aan
was er een andere interface die de computerwereld domineerde: de
\emph{command-line} interface.

Deze inleidende sessies gaan over de command-line interface (of
\emph{commandolijninterface}). Deze is  helaas (veel) minder intuïtief, maar
daarom niet minder belangrijk is om wat ervaring mee te hebben. Met enige kennis
van de command-line programma's, en hoe je die kan combineren met elkaar, kan je
je leven later (hopelijk) veel makkelijker maken (en dat niet alleen in de
eigenlijke practica van \emph{computerarchitectuur}, maar ook in andere vakken
van de opleidingen computerwetenschappen en elektrotechniek, en misschien zelfs
je thesis). Een grote sterkte van de command line op Linux (die voortvloeit uit
een rijke traditie van command line interfaces die ontstaan is in de jaren '70
en '80 en ontwikkeld werden voor Unix-systemen), is dat deze het zeer eenvoudig
maken om zeer complexe tekstoperaties en bestandssysteemoperaties met elkaar te
combineren. De uitvoer van veel programma's is simpelweg tekst, wat het
uitermate handig maakt om de uitvoer van programma's te filteren, combineren,
etc. Bij wijze van voorbeeld: je kan alle PDF-bestanden zoeken op je systeem, en
die dan filteren op degenen die de tekst \emph{``Voorstel tot het bevriezen van
$n$ postgraduaatsopleidingen''} bevatten, waarbij $n$ gelijk welk natuurlijk
getal is; je kan de uitvoer van een simulator zo herstructureren dat je de
interessante data rechtstreeks in een spreadsheet kan plakken, etc.

\section{Organisatie van de sessies}

Deze inleidende sessies gaan door tijdens de eerste drie lesweken, elke dinsdag
van 8u30 tot 9u40, in PC-klassen A en B in de Plateau. Je gaat hier op twee
manieren met Linux leren werken:

\begin{enumerate}

  \item Met enkele oefeningen op Dodona. Deze oefeningen zullen gradueel
    beschikbaar gemaakt worden op de Dodona-site die je kan vinden op
    \url{https://dodona.ugent.be/nl/courses/79/}.

  \item Door te oefenen op een virtueel Linux-systeem dat jullie in VirtualBox
    zullen opzetten. Installeer hiervoor eerst VirtualBox
    (\url{https://www.virtualbox.org/}), end download onze image op
    \url{https://users.elis.ugent.be/~bcoppens/kubuntu-computerarchitectuur.7z}.
    \textbf{Gelieve deze stappen reeds op voorhand te voltooien zodat we hier
    tijdens de labo's zelf niet te veel tijd aan verliezen.} Indien je wil
    werken op een PC in de practicumzaal, zet dan best de (gedecomprimeerde)
    image al op een USB stick. Op dit Linux-systeem hebben we voor jullie al
    een gebruiker \emph{student} aangemaakt wiens \textbf{wachtwoord} ook
    simpelweg \emph{student} is.

\end{enumerate}

De structuur van de sessies zal er als volgt uitzien (voorlopige planning, onder voorbehoud):

\begin{itemize}

  \item \emph{Week 1}: Inleiding tot de command line, de meest simpele
    bestandssysteemoperaties, eenvoudige tekstoperaties, en \emph{reguliere
    expressies}.

  \item \emph{Week 2}: Het combineren van verschillende operaties tot veel
    krachtigere en complexere pijplijnen aan de hand van \emph{pipes} en
    \emph{redirects}, geavanceerdere reguliere expressies, en hoe simpele
    C(++)-programma's te compileren vanaf de command line.

  \item \emph{Week 3}: Meer geavanceerde toepassingen van de concepten van de
    eerste twee weken, Linux-systemen op het internet beheren met een
    \emph{remote shell}, en een korte introductie tot \emph{git}.

\end{itemize}

Het materiaal behorende tot weken 2 en 3 zal voor die lessen online komen.
\textbf{Deze handleiding zal dus ook nog twee keer aangepast worden met het nu
nog ontbrekende materiaal van weken 2 en 3!}

\part{Week 1}
\chapter{Het bestandssysteem in Linux}
Voor we beginnen met het echte werk, is het nuttig om enkele basisconcepten
te kennen van het bestandssysteem, en hoe je kan verwijzen naar bestanden.

Standaard zijn alle verwijzingen naar bestanden \emph{relatief ten opzichte van
de huidige directory}. Dus als je weet dat je directory zit die een
(sub)directory \verb!computerarchitectuur_practica! bevat, kan
je met de verwijzijng \verb!computerarchitectuur_practica! direct naar deze
subdirectory verwijzen.

Directories en bestanden daarin worden van elkaar gescheiden door een forward
slash (/). Dus, \verb!computerarchitectuur_practica/README! verwijst naar
het \verb!README!-bestand in de \verb!computerarchitectuur_practica! directory.

Merk op dat voor Linux een directory eigenlijk een speciaal bestand is. Dus
als je vraagt om alle bestanden in een directory op te lijsten, zal je dus
niet alleen de `gewone' bestanden zien, maar ook alle (sub)directories.

Je kan ook werken met \emph{absolute paden}. In Windows is dit typisch iets wat
begint met \verb!C:\!, \verb!D:\!, etc.. In Unix-gebaseerde systemen zoals
Linux (maar ook OS X),
beginnen deze echter steeds met een initiële forward slash. Alle bestanden zijn
dus te vinden via verwijzingen die starten vanaf de zogeheten
\emph{root-directory}. Al je schijven, USB-sticks, etc., zitten in eenzelfde
directorystructuur. Een voorbeeld van zo'n pad is de
home-directory van de gebruiker: \verb!/home/student!. Dit wil zeggen dat we starten vanaf de
root-directory \verb!/!, die een subdirectory \verb!home! bevat, die dan op zijn
beurt een subdirectory \verb!student! bevat.


\chapter{Inleiding tot de command line}

Start in je Linux virtuele machine een \emph{terminal} op door het programma
\emph{Konsole} te starten. (Zoals zo vaak in de Linux-wereld zijn er
duizend-en-één verschillende mogelijkheden beschikbaar, waarvan Konsole er
slechts één is.) Eerst gaat dit wat uitvoer produceren die je voorlopig mag
negeren (er start namelijk een programma dat automatisch de meest recente
opgaves op je systeem zal downloaden). Na even te wachten, zal je dan volgende
\emph{prompt} te zien krijgen:

\begin{verbatim}
student@student-VirtualBox:~$ 
\end{verbatim}

Deze prompt vraagt (of `prompt') achter nieuwe commando's om uit te voeren. De
tekst duidt aan dat deze sessie draait op het systeem genaamd
\emph{student-VirtualBox} (later zullen we inloggen op een ander systeem met een
andere naam), als gebruiker \emph{student}. De naam van de gebruiker vind je dus
voor de \texttt{@}, de naam van het systeem na de \texttt{@}. Wat er tussen de
\texttt{:} en de \texttt{\$} staat, is de \emph{directory} waar je je op dit
moment bevindt. Standaard zal een terminal starten in de \emph{home-directory}
van de ingelogde gebruiker; deze wordt doorgaans afgekort als \texttt{\~}.

Om er achter te komen in welke directory we ons eigenlijk bevinden, gaan we het
eerste commando invoeren, \verb!pwd! (\emph{Print Working Directory}):

\begin{verbatim}
student@student-VirtualBox:~$ pwd
/home/student
\end{verbatim}

In de loop van deze sessies zal je nog veel meer van deze commando's tegenkomen
met enigszins obscure namen, waar je een hele reeks meer en minder gekende
opties aan kan meegeven. Om meer te lezen over een bepaald commando en de opties
die het ondersteunt kan je beroep doen op de \emph{man-pages}, die een soort van
handleiding vormen. Je kan deze opvragen met het commando \verb!man!. Stel je
voor dat je je afvraagt wat de mogelijke opties zijn van het \verb!ls!-commando
(dat we zometeen gaan zien). Dit doe je via:

\begin{verbatim}
student@student-VirtualBox:~$ man ls
\end{verbatim}
waarna je in een zeer simpele textviewer terecht komt met de handleiding van het
\verb!ls!-commando. Helemaal bovenaan staan heel summiere uitleg van wat het
programma doet, een summier overzicht van de mogelijke opties, gevolgd door een
heel uitgebreide beschrijving van al die opties, eventueel gevolgd door
voorbeelden en aandachtspunten. Deze viewer moet echter ook op een specifieke
manier bediend worden:

\begin{itemize}

  \item \emph{Scrollen} door de tekst kan je met de pijltjes omhoog en omlaag,
    en door PageUp en PageDown.

  \item \emph{Zoeken} door de tekst, kan je door forward slash (`/') te typen,
    gevolgd door je zoekterm (als je bijvoorbeeld in het geval van \verb!ls! wil
    weten hoe de uitvoer gesorteerd kan worden, kan je `sort' typen), en dan op
    \emph{enter} duwen. Alle hits op die zoekterm zullen oplichten in de tekst,
    en de viewer springt automatisch naar de eerste hit. Je kan bovendien
    eenvoudig naar de volgende/vorige hit in de tekst gaan met respectievelijk
    de toetsen `n' (\emph{next}) en `p' (\emph{previous}).

  \item {Afsluiten} van de viewer kan je doen door de `q'-toets (\emph{quit}).

\end{itemize}

\chapter{Simpele bestandssysteemoperaties}

We gaan een aantal heel simpele bestandssysteemoperaties bekijken. Vergeet niet
dat je meer details hierover (zoals extra opties) kan opzoeken in de relevante
man-pages.

\section{\texttt{ls} --- List Files/Directory Contents}

Het \verb!ls!-commando laat toe om de inhoud van een directory te bekijken, en
om meer details over de  bestanden weer te geven. Als je geen specifieke
bestanden of directories meegeeft als argument, dan zal het informatie
uitprinten over de huidige
directory. Standaard zal het \emph{énkel} de lijst van bestanden (en dus ook
directories) in de huidige directory uitprinten:

\begin{verbatim}
student@student-VirtualBox:~$ ls
computerarchitectuur_practica Desktop Documents Downloads Music Pictures Public
Templates Videos
\end{verbatim}

Dit wil dus zeggen dat je home-directory 9 bestanden (in dit geval alleen
directories) bevat.

Je de bestanden in die (sub)directory als volgt printen: \verb!ls computerarchitectuur_practica!
(merk dus op dat we hier nu gebruiken van een relatief pad). Je kan even
goed ook verwijzen naar een subdirectory: Nu je weet dat in die directory
een subdirectory \verb!pract01!
zit, kan je die inhoud laten zien door het commando
\verb!ls computerarchitectuur_practica/pract01!
te typen.


\textbf{Belangrijke tip!} Je gaat het misschien net als ik ook al beu zijn om
elke keer opnieuw \verb!computerarchitectuur_practica! voluit te typen. Dat is
saai, traag, en foutgevoelig. De \emph{shell} (het programma waarmee je
interageert in de terminal en die je \verb!student@student-VirtualBox:~$!
print), heeft gelukkig een feature die dit probleem zo goed als volledig oplost:
\emph{tab completion}. Je typt gewoon het begin van een bestand/directory, en
drukt de tab-toets in. De shell zal dan zo ver mogelijk aanvullen als hij kan,
gegeven de bestanden in de directory. Dus bij
\verb!computerarchitectuur_practica! weet je nu dat dit het \'enige bestand is
in de home-directory dat begint met de letter \verb!c!. Dus kan je gewoon typen:
\verb!ls c!\emph{tab}, waarna automatisch alles wordt aangevuld. Die directory
heeft nu 8 practica-subdirectories. Dus kan je
\verb!computerarchitectuur_practica/p!\emph{tab} typen, waarna dit wordt
aangevuld tot \verb!computerarchitectuur_practica/pract0!. Aangezien er echter 8
verschillende subdirectories zijn, kan de shell dit uiteraard niet aanvullen tot
op het einde. In dit geval is het handig om 2 keer op tab te duwen:
\verb!computerarchitectuur_practica/pract0!\emph{tab} \emph{tab}: dan laat de
shell alle bestanden zien die beginnen met \verb!pract0!, zodat je makkelijk dat
karakter zelf kan typen (en dan eventueel weer verder aan te laten vullen door
weer op \emph{tab} te duwen).

Probeer eens op de volgende 3 manieren de inhoud van
\verb!computerarchitectuur_practica! te laten zien: met een relatief pad, met
een absoluut pad, en met een pad relatief ten opzichte van de shortcut voor de
homedirectory \verb!~!. Maak hierbij gebruik van tab completion.

Je kan ook meer informatie laten printen door \verb!ls!. De meest handige manier
is \verb!ls -lh!, wat onder andere de grootte print van het bestand. Probeer dit
eens uit met \verb!ls -lh /bin/!. Gebruik de man-page om te achterhalen wat de
\verb!l! en \verb!h! opties precies betekenen. (Voor de rest is het allicht ook
interessant om weten dat je kan sorteren op allerhande soorten informatie, als
je meer hierover wil weten kan je dat opzoeken in de man-page.)

\section{\texttt{cd} --- Change Directory}

Enerzijds kennen we nu het concept van `de huidige directory', en anderzijds
weten we hoe \verb!ls! te gebruiken om te zien welke directories (of files) er
waar zijn. Met \verb!cd! kunnen we onze huidige directory veranderen naar de
andere directory. Zo kunnen we naar de
\verb!computerarchitectuur_practica!-directory gaan, en verolgens het
\verb!ls!-commando uitvoeren. De inhoud van de
\verb!computerarchitectuur_practica!-directory zal dan getoond worden:

\begin{verbatim}
student@student-VirtualBox:~$ cd computerarchitectuur_practica
student@student-VirtualBox:~/computerarchitectuur_practica$ ls
pract01 pract02 pract03 pract04 pract05 pract06 pract07
pract08 README
\end{verbatim}

De prompt geeft hier meteen mooi aan dat de huidige directory veranderd is.

Je kan verwijzen naar de bovenliggende directory via \verb!..!. Dit kan je
gebruiken om omhoog te gaan in de directorystructuur:
\begin{verbatim}
student@student-VirtualBox:~/computerarchitectuur_practica$ cd ../..
student@student-VirtualBox:/home$ 
\end{verbatim}

Hier verplaatsen we ons dus naar de bovenliggende directory van de bovenliggende
directory, wat in dit geval \verb!/home! is.

\section{\texttt{mkdir} --- Make Directory}

We kunnen nieuwe directories aanmaken met het \verb!mkdir! commando: \verb!mkdir nieuwedirectory!. De verwijzing naar de nieuwe directory kan zowel relatief als
absoluut zijn, maar standaard gaat het commando er van uit dat slechts de meest
diepe directory moet worden aangemaakt, en alle tussenliggende directories reeds
bestaan. Zoek op in de man-page hoe je \verb!mkdir! deze directories ook kan
laten aanmaken voor je.

\section{\texttt{cp} --- CoPy Files}

Met het \verb!cp!-commando kan je bestanden kopiëren. Er zijn twee mogelijkheden:

\begin{itemize}

  \item Het doel is een bestandsnaam: \verb!cp bestand1 bestand2! zal
    \verb!bestand1! kopiëren naar een bestand met de naam \verb!bestand2!.

  \item Het doel is een directory: \verb!cp bestand1 directory! zal een kopie
    van \verb!bestand1! aanmaken in \verb!directory!; het nieuwe bestand zal (in
    die directory) dezelfde naam hebben als het originele bestand. In dit geval
    kan je ook meerdere bestanden in 1 keer kopieren: \verb!cp bestand1 bestand2 bestand3 directory!.

\end{itemize}

Probeer eens een bestand uit de \verb!/bin!-directory te kopiëren naar een
directory die je zonet hebt aangemaakt, en verifieer dat de kopie even groot is
als het origineel.

\section{\texttt{mv} --- MoVe Files}

Het \verb!mv!-commando werkt net als het \verb!cp!-commando, maar het verplaatst
de bestanden in plaats van ze te kopiëren. Volledig gelijkaardig met \verb!cp!
kan het doel een bestandsnaam of een directory zijn.

\section{\texttt{rm} --- ReMove Files}

Tot slot willen we ook bestanden kunnen verwijderen. Dit kan met het
\verb!rm!-commando.

\section{\texttt{cat} --- Een slechte textviewer}

Het \verb!cat!-commando gaat de inhoud van bestanden die het meekrijgt als
argument gewoon achter elkaar naar scherm printen. Probeer eens een bestand uit
de \verb!computerarchitectuur_practica! directory op scherm te printen.

\section{\texttt{less} --- Een simpele textviewer}

Het \verb!cat!-commando is niet zo handig om tekst mee te bekijken. Het zou veel
handiger zijn als we de textviewer die gebruikt wordt voor de man-pages zouden
kunnen hergebruiken. Gelukkig is dit mogelijk: dit is het \verb!less!-commando.
Probeer met \verb!less! eens hetzelfde bestand te bekijken als je zonet deed met
\verb!cat!.

\section{\texttt{touch} --- Een leeg bestand aanmaken}

Met het \verb!touch!-commando kan je een leeg bestand aanmaken. (Dit commando
heeft eigenlijk een ander doel, zoals je kan lezen in de man-page. Maar als je
het als argument een bestandsnaam geeft die nog niet bestaat, zal het dat
bestand aanmaken.)

Maak in je homedirectory eens een leeg bestand \verb!A! aan. Net zoals bij de
vorige commando's, kan je ook meerdere argumenten aan dit commando meegeven. Elk
van die bestanden zal dan worden aangemaakt.

\textbf{Belangrijk!} De verschillende argumenten van een commando worden door
een spatie van elkaar gescheiden. Maar als nu een van de argumenten een
bestandsnaam is die een spatie bevat, wat dan? Dan kan je dat argument tussen
een koppel enkele quote-tekens (\verb!'!) zetten: alles wat daartussen staat,
wordt beschouwd als hetzelfde argument, inclusief spaties. Als we bijvoorbeeld 3
bestanden willen aanmaken, waarvan één bestand wiens naam spaties bevat, kan je
dit als volgt doen:

\begin{verbatim}
student@student-VirtualBox:~$ touch bestand1 'bestandsnaam 2 met spaties' bestand3
\end{verbatim}

Probeer dit zelf eens, en kijk ook hoe dit er uit ziet met zowel \verb!ls! als
\verb!ls -lh!. Probeer zo'n bestand ook eens te kopiëren. Merk bovendien ook op
dat het geen kwaad kan om ook quote-tekens te zetten rond argumenten zonder
spatie:

\begin{verbatim}
student@student-VirtualBox:~$ touch 'bestand4' 'bestand5'
\end{verbatim}

Dit zal 2 extra bestanden aanmaken, waarbij de quotes geen deel uitmaken van de
bestandsnaam. Je kan in principe ook dubbele quotes (\verb!"zoals dit"!)
gebruiken, maar die hebben een subtiel andere betekenis dan de enkele quote die
ik hierboven demonstreerde. Het verschil zal je zien in sessie 3; gebruik tot
dan voor de veiligheid gewoon de enkele quotes.

\chapter{Simpele tekstoperaties}

Nu gaan we ook echt iets doen met deze tekstbestanden. In deze sessie houden we
het eenvoudig: we gaan simpelweg de inhoud van bestanden doorzoeken en
herordenen.

\section{\texttt{cut} --- Herordenen van kolommen}

Met het \verb!cut!-commando kan je tekstbestanden onderverdelen in kolommen, en
dan een deelverzameling van die kolommen uitprinten op het scherm (in de
volgorde die jij wil). De kolommen (\emph{fields}) die je wil printen, geef je
aan met het argument dat volgt op \verb!-f!. Het \verb!cut!-commando verdeelt
een lijn onder in verschillende kolommen afhankelijk van een \emph{delimiter}.
Zoals je in de man-page al kan zien, is deze delimiter standaard een
tab-karakter, wat in de praktijk nogal onhandig is; die kan je makkelijk
aanpassen met \verb!-d!.

Om een simpel voorbeeld te geven, het bestand \verb!/etc/passwd! bevat
informatie over de gebruikers op het systeem. De verschillende velden zijn van
elkaar gescheiden door een \verb!:!-karakter. Als je dan bijvoorbeeld per
gebruiker de volledige naam (het vijfde veld) en de home-directory van die
gebruiker (het zesde veld) wil uitprinten, kan je dit doen als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ cut -d : -f 5,6 /etc/passwd
\end{verbatim}

Probeer eens een spatie als delimiter te gebruiken?

\chapter{Reguliere expressies}

Reguliere expressies zijn uitdrukkingen die je toestaan om simpele zoekpatronen
(dit zijn dan de expressies) te beschrijven die meer zijn dan enkel letterlijke
stukken tekst. Achter dit concept zit een heel interessante theoretische
achtergrond, die volledig buiten de scope van dit document valt. Wat belangrijk
is, is wat je er mee kan en hoe je ze opbouwt.

Je doorzoekt een of meerdere tekstbestanden met een reguliere expressie als
volgt: \verb!egrep '!\emph{patroon}\verb!' bestand(en)!. Dit gaat alle lijnen
uitprinten in de gegeven bestanden die voldoen aan de gegeven reguliere
expressie/zoekpatroon. Zo'n patroon zet je opnieuw best tussen quotes, niet
alleen omdat een patroon spaties kan bevatten, maar ook omdat bepaalde
zoekpatronen speciale karakters zijn in de shell, en door die in quotes te
zetten verliezen ze hun speciale betekenis.

Een regulier expressie bouw je op uit kleinere sub-expressies. De belangrijkste sub-expressies en manieren om ze op te bouwen zijn:

\begin{itemize}

  \item \emph{Letterlijk karakter:} Dit geef je gewoon letterlijk in.
    Bijvoorbeeld: \verb!egrep 'a' bestand.txt! zoekt geeft alle lijnen die het
    karakter \emph{a} bevatten in het bestand \verb!bestand.txt!

  \item \emph{Aan elkaar plakken van expressies (concatenation)}: door
    expressies achter elkaar te plakken, ga je zoeken op de regels die die
    opeenvolging van expressies bevatten. Zoals je weet van het vorige puntje,
    is een enkel karakter een expressie; je kan die dan zoals je zou verwachten
    achter elkaar typen om volledige zinnen te zoeken. Bijvoorbeeld,
    \verb!egrep 'Linux is tof' bestand.txt! zoekt op de tekst \emph{Linux is
    tof} (dat is dus de opeenvolging van de tekens \emph{L, i, n, etc.} in het
    bestand \verb!bestand.txt!.

  \item \emph{Eender welk karakter:} Als je het \verb!.!-karakter in een
    reguliere expressie op een bepaalde plaats zet, zal gelijk welk karakter
    daar mogen voorkomen. Bijvoorbeeld: \verb!egrep 'm.h' bestand.txt! zal alle
    regels uitprinten die tekst bevatten die de vorm heeft van `m, gevolgd door
    gelijk welk karakter, gevolgd door h'.

  \item \emph{Een bereik (range) van karakters:} soms is \verb!.! te ruim, en
    wil je enkel regels die op een bepaalde positie een beperkt bereik van
    karakters toestaan. Dit kan je doen door al die karakters tussen vierkante
    haakjes te zetten. Bijvoorbeeld: \verb!Bar[td]! is een patroon dat zowel
    \emph{Bart} als \emph{Bard} zal matchen. Als het bereik groot is, maar op
    elkaar volgt in de ASCII-tabel, kan je dit afkorten door een streepje: het
    patroon \verb![a-d]! zal \emph{a,b,c,d} matchen.

  \item \emph{Een keuzemogelijkheid:} als je lijnen wil printen die een van
    meerdere zoekpatronen matcht, kan je die scheiden van elkaar met een
    vertikaal streepje, ook wel het \emph{pipe symbol} genoemd: \verb!|!.
    Bijvoorbeeld, \verb!Aap|Noot|Mies! zal alle lijnen printen die minstens
    eenmaal \emph{Aap}, \emph{Noot}, of \emph{Mies} bevatten.

  \item \emph{Herhaling, 0 of meer keer:} Als je het voorgaande element 0 of
    meer keer wil herhalen, dan zet je hier een asterisk na: \verb!ka*t! zal
    zowel matchen op \emph{kt}, \emph{kat}, \emph{kaat}, etc. Dit werkt
    uiteraard ook op andere types referenties, \verb![0-9]*! zal matchen op
    gelijk welke opeenvolging van cijfers (en ook 0 cijfers).

  \item \emph{Herhaling, 1 of meer keer:}, hiervoor gebruiken we een plus-teken.
    Dus \verb![0-9]+! zal matchen op elk getal, dat minstens uit \'e\'en cijfer
    bestaat.

  \item \emph{Herhaling, bereik:} dit doe je met accolades en het aantal keer
    dat het herhaald wordt ertussen. Bijvoorbeeld, als je exact een Googol wil
    matchen, wat een 1 is gevolgd door 100 0'en, dan kan je dit doen als volgt:
    \verb!10{100}!. (Dus om precies te zijn: het element voor de accolades is
    een 0, en dat moet 100 keer worden herhaald.) Je kan ook een heel bereik
    opgeven (tussen twee getallen, ten hoogste een bepaald getal), de exacte
    syntax hiervan kan je in de man-page van egrep vinden.

  \item \emph{Groeperen:} De bovenstaande operaties slaan steeds op het vorige
    \emph{element} in de expressie. Aangezien individuele karakters ook al
    expressies zijn, wil dit zeggen dat de expressie \verb!Noot{2}! \'enkel zal
    matchen op \emph{Noott} (dus een dubbele \emph{t}), maar ni\'et op
    \emph{NootNoot}. Om die operaties op een samenstelling van expressies te
    zetten, zet je die samenstelling tussen ronde haakjes. Wat tussen ronde
    haakjes staat, zal dan worden aanzien als een enkele expressie. Dus om
    \emph{NootNoot} te matchen, kan je dus de expressie \verb!(Noot){2}!
    gebruiken.

  \item \emph{Begin van een regel:} Dit geef je aan met het teken \verb!^!. Dus
    \verb!^A! gaat enkel op regels matchen die beginnen met een \emph{A}.

  \item \emph{Einde van een regel:} Dit geef je aan met het teken \verb!$!. Dus
    \verb!A$! gaat enkel op regels matchen die eindigen op een \emph{A}.

\end{itemize}

Een voorbeeldje:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd
\end{verbatim}

zal alle regels in \verb!/etc/passwd! uitprinten die eindigen op ofwel
\verb!nologin! ofwel op \verb!false!. Bovendien zal de omgeving die wij
gebruiken, \verb!egrep! standaard zo instellen dat de specifieke delen die
gematcht worden, gekleurd worden, zodat je duidelijk kan zien waar de matchende
expressies voorkomen in elke lijn.

Standaard gaat \verb!egrep! hoofdlettergevoelig zoeken. Dit wil zeggen dat \verb!egrep 'e'! niet hetzelfde is als \verb!egrep 'E'!: het eerste zal enkel lijnen weergeven die een kleine letter \emph{e} bevatten, het tweede enkel lijnen met een hoofdletter \emph{E}. Je kan die hoofdlettergevoeligheid uitzetten met de \verb!-i! optie: \verb!egrep -i 'e'! zal zowel de hoofdletter als kleine letter \emph{e} matchen.

Tot slot kan je \verb!egrep! ook gebruiken om de zoekpatronen te \emph{inverteren}: met de \verb!-v! optie (inVert), inverteer je het zoekpatroon: \verb!egrep! zal dan enkel de lijnen uitprinten die \emph{ni\'et} voldoen aan het zoekpatroon.

\textbf{Oefeningen} Op Dodona kan je hierover enkele extra oefeningen vinden! Ik zou aanraden om deze zeker te maken.

\part{Week 2}

\chapter{Redirects}

Vorige week hebben we gezien hoe we tekstoperaties konden doen op bestanden.
Deze waren reeds nuttig afzonderlijk, maar deze week gaan we zien hoe ze veel
nuttiger te maken: we gaan de uitvoer van programma's opvangen en daar
allerhande dingen mee doen.

Zoals het je vorige week misschien is opgevallen, kunnen sommige commando's veel
uitvoer op het scherm genereren. Dit is niet overzichtelijk bepaald
overzichtelijk, en moeilijk te doorzoeken. Om op gemakkelijkere wijze iets met
deze uitvoer te kunnen doen, gaan we beginnen met de uitvoer te
\emph{redirecten} naar een bestand. De meest simpele manier om dit te doen, is
door een groter-dan teken te plaatsen na het commando, gevolgd door een
bestandsnaam waar de uitvoer naar geschreven moet worden. Bijvoorbeeld:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd > bestand.txt
\end{verbatim}

maakt het bestand \verb!bestand.txt! aan in de huidige directory (in dit geval:
de home-directory), met daarin de uitvoer van het \verb!egrep!-commando.

Probeer zelf eens de uitvoer van een van je commando's van vorige week naar een
bestand te schrijven.

Natuurlijk rijst dan de vraag: wat gebeurt er als je de uitvoer redirect naar
een bestand dat reeds bestaat? Dit bestand wordt dan \emph{overschreven}. Wil je
dat de uitvoer van een programma achteraan een reeds bestaand bestand wordt
toegevoegd (\emph{appended}), dan gebruik je een dubbele groter-dan:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd >> bestand.txt
\end{verbatim}

zal de uitvoer van het \verb!egrep!-commando \emph{achteraan toevoegen} aan
\verb!bestand.txt!.

Zoals je misschien weet, kunnen programma's uitvoer wegschrijven via
verschillende soorten \emph{(output)streams}, die onafhankelijk zijn van elkaar.
Het gaat hier over \emph{standard output} (in Python is dit waar je standaard
impliciet naar schrijft via \verb!print()!, of expliciet naar schrijft via
\verb!sys.stdout!; in Java is dit \verb!System.out!), en \emph{standard error}
(in Python is dit \verb!sys.stderr!, in Java is dit \verb!System.err!). De
eerste stream dient om normale uitvoer naar te schrijven, de tweede dient om
alle informatie over fouten naar toe te schrijven.

Het redirecten van uitvoer met een (enkele of dubbele) groter-dan zoals
hierboven slaat énkel op standard output. Fouten zullen dus niet geredirect
worden naar een bestand, maar nog altijd op het scherm verschijnen:

\begin{verbatim}
student@student-VirtualBox:~$ ls /dit/bestand/bestaat/niet > bestand.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ cat bestand.txt
student@student-VirtualBox:~$
\end{verbatim}

Wil je énkel standard error redirecten, dan doe je dit met de syntax \verb!2>!.
Als je zowel standard output als standard error wil redirecten naar eenzelfde
bestand, dan doe je dit met de syntax \verb!&>!:

\begin{verbatim}
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet 2> error.txt
/etc/passwd
student@student-VirtualBox:~$ cat error.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet 2> error.txt > bestand.txt
student@student-VirtualBox:~$ cat bestand.txt
/etc/passwd
student@student-VirtualBox:~$ cat error.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet &> alles.txt
student@student-VirtualBox:~$ cat alles.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
/etc/passwd
\end{verbatim}

\chapter{Pijplijnen van commando's}

Veel van de Linux-tools voor tekstoperaties die we eerder gezien hebben, zoals
\verb!egrep!, kunnen die operaties niet enkel toepassen op bestanden, maar ook
op een \emph{input stream}. Door geen bestanden als argument mee te geven, gaat
zo een tool automatisch de tekstoperaties uitvoeren op de invoer uit
\emph{standard input} (en zoals altijd de uitvoer naar standard output sturen).
In het geval dat je eens een programma opstart zonder bestandsargumenten, kan je
zelf de inputstream afsluiten door \emph{Ctrl+d} in te drukken. Probeer dit zelf
eens met \verb!egrep 'Hallo'!, en dan eens zowel niet-matchende tekst als
\emph{Hallo} in te geven.

Nu je weet dat zulke tools ook een stream als invoer kunnen gebruiken, is de
logische volgende stap natuurlijk om de invoer en uitvoer van meerdere tools aan
elkaar te hangen, en er een \emph{pijplijn} van te maken. Zo kan je bijvoorbeeld
de uitvoer van een \verb!egrep!-operatie doorsturen als invoer van een
\verb!cut!-operatie. Dit doen we door middel van de vertikale streep (\verb!|!,
ook wel \emph{pipe} genoemd) tussen de operaties te zetten. Bijvoorbeeld:
\begin{verbatim}
student@student-VirtualBox:~$ egrep 'student' /etc/passwd | cut -d : -f 6 /home/student
\end{verbatim}

houdt enkel de lijnen van \verb!/etc/passwd! over die \emph{student} bevatten,
en gaat enkel die lijnen onderverdelen in kolommen (met : als delimiter), en
print daarvan de 6e kolom. Je kan je pijplijnen zo lang maken als je zelf wil.
Uiteindelijk kan je dan het eindresultaat naar een bestand wegschrijven om later
te editeren of bekijken. Een andere handige tip is om het \verb!less!-commando
de laatste stap van je pijplijn te maken: dan kan je makkelijk scrollen en
zoeken in het resultaat.

Probeer eerst zelf eens als opwarmertje om in het woordenboek dat je kan vinden
op \verb!/usr/share/dict/words! te zoeken op alle woorden die eindigen op het
suffix \emph{ily}, en pipe deze verolgens naar het \verb!less!-commando.

Op Dodona vind je nog een reeks opgaven over pijplijnen met simpele
tekstoperaties. Probeer deze op te lossen.

\chapter{Geavanceerde reguliere expressies}

Bovenop de concepten van reguliere expressies die we vorige week gezien hebben,
zijn er nog twee gerelateerde concepten die nuttig zijn in de praktijk:
backreferences en het gebruiken van reguliere expressies om tekst automatisch
aan te passen.

\section{Backreferences}

Bij backreferences ga je in je expressie expliciet vragen dat bepaalde delen van
een match op een andere plaats ook voorkomen, door naar die delen te verwijzen
in de expressie. We hebben reeds gezien dat we een groep kunnen aanmaken in een
reguliere expressie met behulp van ronde haakjes; je kan later in je expressie
verwijzen naar wat tussen die haakjes stond met behulp van de syntax  $\\n$
(waarbij $n$ aangeeft naar welke groep verwezen wordt, en er vanaf 1 gestart
wordt met tellen). Dus bijvoorbeeld, de expressie \verb!(ba)\1! zal zoeken naar
de lijnen die \emph{baba} bevatten. Natuurlijk is dit niet zo nuttig als je
enkel volledige strings matcht. Dit wordt echter veel handiger als je naar
groepen verwijst die gebruik maken van patronen. Bijvoorbeeld, \verb!egrep '(b.)\1' /usr/share/dict/words! zoekt naar alle woorden die een \emph{directe
herhaling} bevatten van de karaktersequentie \emph{b, gevolgd door gelijk welk
teken}. Dit zal dus matchen op \emph{im\textbf{bibi}ng}, maar niét op
\emph{imbibe} (het gematchte teken is immers niet hetzelfde).

\textbf{Nuttig om weten} is dat veel programmeertalen (of hun
standaardbibliotheken) ondersteuning bieden om allerhande operaties met
reguliere expressies uit te voeren. Zo heeft Python bijvoorbeeld de
\verb!re!-module die je hiervoor kan gebruiken:
\url{https://docs.python.org/3/library/re.html}.

Op Dodona vind je een aantal oefeningen op het gebruik van zo'n backreferences,
los deze op.

\section{Stream editing met reguliere expressies}

Soms willen we bepaalde sequenties in een tekst verwijderen of veranderen.
Hierbij kunnen we gebruik maken van het \verb!sed!-commando. Dit is een vrij
krachtig commando, waarvan we \emph{enkel} de functionaliteit gaan gebruiken om
stukken tekst te matchen en veranderen met reguliere expressies. Dit werkt als
volgt: \verb!sed -e 's/!\emph{zoekpatroon}\verb!/!\emph{vervangpatroon}\verb!/g'!. (Met optioneel
een laatste argument dat een bestand is; indien dit niet gegeven wordt, zal het
lezen van zijn input stream.) De \verb!-e! geeft aan dat we een sed-expressie
meegeven. In die expressie geeft de \verb!s! aan dat we een \emph{substitutie}
gaan doen, van het patroon tussen het de eerste en tweede slash, door het
patroon tussen de tweede en derde slash. De \verb!g! achteraan geeft aan dat dit
patroon per lijn \emph{globaal} vervangen mag worden. Indien je dit niét
meegeeft, gaat per lijn slechts de eerste match vervangen worden. Meestal wil je
echter alle voorkomens van een patroon vervangen. Bijvoorbeeld:

\begin{verbatim}
student@student-VirtualBox:~$ sed -e 's/:/ /g' /etc/passwd
root x 0 0 root /root /bin/bash
daemon x 1 1 daemon /usr/sbin /usr/sbin/nologin
....
student@student-VirtualBox:~$ sed -e 's/:/ /' /etc/passwd
root x:0:0:root:/root:/bin/bash
daemon x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...
\end{verbatim}

Ook hier wordt het nog interessanter eens je complexere expressies in je
zoekpatronen gebruikt. Bovendien kan je in je substitutie ook verwijzen naar
groepen in je zoekexpressie, om zo dingen van plaats te veranderen.
\textbf{Opgelet}: de syntax voor reguliere expressies is in \verb!sed! helaas
iets omslachtiger dan \verb!egrep!. De operators \verb!+!, \verb!?!, \verb!{}!,
en \verb!()! moeten voorafgegaan worden door een backslash (\verb!\!).
Bijvoorbeeld, in het bestand \verb!/etc/passwd! staan enkele lijnen waarbij de
gebruikersnaam (het veld voor de eerste \verb!:!) een streepje bevat. Willen we
nu eens dat bestand editeren zodat hetgeen voor en na het streepje staat van
plaats gewisseld wordt (zodat \verb!systemd-network! wordt omgezet in
\verb!network-systemd!, en alle andere lijnen ongewijzigd blijven), kan dit als
volgt:

\begin{verbatim}
sed -e 's/^systemd-\([^:]\+\):/\1-systemd:/g' /etc/passwd
\end{verbatim}

Merk hierbij op dat (net zoals bij \verb!egrep!) een \verb!^! aan het begin van
een karakterbereik aangeeft dat dit karakterbereik ge"inverteerd moet worden:
\verb![^:]! is dus gelijk welk teken dat géén \verb!:! is.

Probeer te begrijpen hoe deze vervang-expressie werkt.

Ook hierover staan er weer wat oefeningen op Dodona (al dan niet in combinatie
met \verb!egrep!).

\chapter{Nano: Een simpele tekstverwerker op de command line}

Normaal gezien gaan jullie je bestanden editeren in een grafische
tekstverwerker, en er vervolgens acties op uitvoeren op de command line. In
sommige omstandigheden kan het echter handig zijn om een bestand te editeren
vanop de command line. Hiervoor bestaan verschillende soorten tekstverwerkers.
Deze week gaan we kennis maken met een heel eenvoudige tekstverwerker:
\verb!nano!. Je start deze editor op met \verb!nano bestand.txt!. Je kan hier
gewoon tekst in typen. Onderaan het scherm staan de acties die je kan doen, en
hoe je ze moet oproepen. Hierbij geeft een hoedje (\^) aan dat je de
\emph{Ctrl-toets} moet ingeduwd houden. Als er onderaan dus staat: \verb!^O Write Out!,
wil dit dus zeggen dat om het bestand weg te schrijven, je \emph{Ctrl+o} moet
typen. Gelijkaardig moet je \emph{Ctrl+x} intypen om de editor te verlaten.

Speel even met \verb!nano! om een klein bestandje te schrijven.


\chapter{Compileren op de command line}

\emph{Compileren} is het omzetten/vertalen van bronbestanden (geschreven in
bijvoorbeeld C) naar uitvoerbare bestanden, die zogeheten \emph{binaire code}
bevatten. Hier gaan we beknopt leren hoe C en C++-bestanden te compileren vanop
de command line. We maken hiervoor gebruik van compilers van de GNU Compiler
Collection: de C compiler \verb!gcc! en de C++ compiler \verb!g++! 

Ruw gesproken bestaat wat je vaak zou beschouwen als compileren eigenlijk
uit twee stappen: het omzetten van \emph{individuele} bronbestanden
in binaire bestanden (ook wel \emph{objectbestanden} of \emph{object files}
genoemd), en het \emph{linken} van al deze objectbestanden in één enkel
uitvoerbaar bestand. We beginne met twee C-bestanden te maken: \verb!print.c! en
\verb!main.c!. Deze hebben de volgende inhoud:

\begin{verbatim}
student@student-VirtualBox:~$ cat print.c
#include <stdio.h>
void print() { printf("Hallo iedereen!\n"); }

student@student-VirtualBox:~$ cat main.c
void print();
int main() { print(); }
\end{verbatim}

Willen we deze twee bestanden compileren en linken tot een uitvoerbaar bestand,
dan gaan we als volgt te werk. Om een bestand te compileren, gebruiken we de
optie \verb!-c! van de respectievelijke compiler (in dit geval \verb!gcc!), en
gebruiken we als argument(en) de bestanden die we willen compileren naar een
objectbestand. De compiler zal deze bestanden automatisch dezelfde naam geven
als de invoerbestanden, maar met het suffix \verb!.o! (verwijzend naar het feit
dat het een objectbestand is). Dus:

\begin{verbatim}
student@student-VirtualBox:~$ gcc -c main.c print.c 
student@student-VirtualBox:~$ ls -lh main.o print.o 
-rw-r--r-- 1 student student 1.4K Feb 18 15:56 main.o
-rw-r--r-- 1 student student 1.5K Feb 18 15:56 print.o
\end{verbatim}

Willen we deze twee bestanden nu tot een uitvoerbaar bestand combineren/linken,
volstaat het om de gebruikte compiler op te roepen, maar deze keer met
objectbestanden als argumenten. Dan moeten we niet meer aangeven dat deze
bestanden gecompileerd moeten worden. De compiler vereist nu wel een naam voor
het finale, gelinkte bestand. Deze naam stellen we manueel in met de optie
\verb!-o!. Tot slot, als je een uitvoerbaar bestand dat je zelf gecompileerd
hebt wil laten uitvoeren, kan je dit niet zomaar intypen. Je moet een
padverwijzing gebruiken die ofwel een absolute verwijzing is, ofwel begint met
een \emph{expliciete verwijzing} vanaf de huidige directory (\verb!./!) (voor de
ge"interesseerden: dit heeft te maken met de \verb!PATH! omgevingsvariabele, je
kan dit gerust eens opzoeken hoe dat werkt, maar dat valt buiten de scope van
deze korte introductie). Als we het uitvoerbaar bestand \verb!hallo! willen
noemen (op Linux gebruik je normaal gezien geen \verb!.exe!-suffix), en dan
uitvoeren, dan kan dit als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ gcc -o hallo main.o print.o
student@student-VirtualBox:~$ ./hallo 
Hallo iedereen!
\end{verbatim}

Wil je optimalisaties gebruiken, dan ga je bij het compileren de
optimalisatievlaggen moeten meegeven met \verb!-O!$n$, waarbij $n$ het verwachte
optimalisatieniveau is, want anders genereert je compiler heel ineffici"ente
code. De bestaande niveaus gaan van \verb!-O0! (geen optimalisaties, maar het
compileren gaat snel), naar \verb!-O3! (heel effici"ente code, maar het
compileren zal trager zijn bij grote codebases). Vaak wordt \verb!-O2! als
tussenweg gekozen:
\begin{verbatim}
student@student-VirtualBox:~$ gcc -O2 -c main.c print.c 
student@student-VirtualBox:~$ gcc -o hallo main.o print.o
\end{verbatim}

Voor C++-programma's is dit allemaal identiek, maar dan met \verb!g++! op beide
plaatsen, in plaats van \verb!gcc!.

\chapter{Make-files}
Wat je voor het compileren van echter vaak in Linux-achtige systemen gaat zien dat mensen de commando's niet elke keer alle compilatiestappen manueel opnieuw gaan uitvoeren. Enerzijds wil je namelijk een scriptje dat voor jou alle compilatiestappen uitvoert, en anderzijds wil je niet elke keer \emph{alle} bestanden hercompileren als je slechts \'e\'en bronbestand aangepast hebt. Hiervoor worden makefiles gebruikt. Dit zijn bestanden die de naam \verb!Makefile! hebben. Deze bevatten regels die een link hebben tussen een \emph{doelbestand}, de verschillende acties die nodig zijn om dat doelbestand te genereren, en de bronbestanden die nodig zijn hiervoor. Lijnen die meteen beginnen met de naam van een bestand, gevolgd door een \verb!:!, geven aan dat deze regels een doelbestand defini"eren. Na de \verb!:! komt dan een lijst van bestanden (dit kunnen zowel bronbestanden als intermediaire bestanden zijn) die nodig zijn om dit doelbestand te genereren. Alle lijnen die volgen op zo'n doelbestand-regel, en bovendien \textbf{beginnen met een tab-karakter}, geven de acties aan die nodig zijn. Finaal wil je dan die makefile gebruiken met het \verb!make!-commando om de regels te triggeren om je doelbestand te genereren. Het \verb!make!-commando gaat dan automatisch de afhankelijkheden berekenen, kijken voor welke doelbestanden (een van) de bronbestanden meer recent gewijzigd is dan het doelbestand zelf, en zal dan slechts enkel die regels uitvoeren. Een voorbeeld van een makefile die hoort bij de C-bestanden van vorig hoofdstuk, zou er als volgt kunnen uitzien:

\begin{verbatim}
student@student-VirtualBox:~$ cat Makefile
hallo: main.o print.o
        gcc -o hallo main.o print.o
main.o: main.c
        gcc -c main.c
print.o: print.c
        gcc -c print.c
\end{verbatim}
waarbij het inspringen \emph{gebeurt met een tab-karakter}. Als we even alle reeds bestaande objectbestand en uitvoerbare bestanden weghalen, kunnen we nu opnieuw beginnen als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ make hallo
gcc -c main.c
gcc -c print.c
gcc -o hallo main.o print.o
\end{verbatim}

Indien we nu \verb!print.c! zouden aanpassen, gaat \verb!make! niet meer \verb!print.o! hergenereren:

\begin{verbatim}
student@student-VirtualBox:~$ make hallo 
gcc -c main.c
gcc -o hallo main.o print.o
\end{verbatim}

Indien we \emph{niets} veranderen, gaat  \verb!make! ook doorhebben dat er niets moet veranderd worden om \verb!hallo! up to date te houden:
\begin{verbatim}
student@student-VirtualBox:~$ make hallo 
make: 'hallo' is up to date.
\end{verbatim}

Het is echter nogal saai om in een makefile altijd expliciet voor elk C-bestand te moeten schrijven hoe je het compileert. Die gaan namelijk allicht allemaal op dezelfde manier gecompileerd moeten worden. Gelukkig ondersteunt \verb!make! ook regels die kunnen matchen op een patroon in een bestandsnaam, en dan acties uit te voeren die gebaseerd zijn op die patronen. Dit zou ons te ver leiden, de ge"interesseerden kunnen hierover meer lezen in de manual op \url{https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html}. Het volstaat om te weten dat voor C-files al zo'n regels impliciet actief zijn als je ze niet zelf defini"eert, en dat je de compilatievlaggen (zoals het optimalisatieniveau) kan instellen door in je makefile een \verb!CFLAGS!-variabele toe te wijzen. Een meer flexibele versie van onze bovenstaande makefile ziet er dan ook als volgt uit:

\begin{verbatim}
student@student-VirtualBox:~$ cat Makefile 
CFLAGS=-O2
hallo: main.o print.o
        gcc -o hallo main.o print.o
bartcopp@solkar:~/phd/postdoc/ca/introlinux-cursus$ rm main.o print.o hallo 
bartcopp@solkar:~/phd/postdoc/ca/introlinux-cursus$ make
cc -O2   -c -o main.o main.c
cc -O2   -c -o print.o print.c
gcc -o hallo main.o print.o
\end{verbatim}

Tot slot is het ook handig om weten dat voor echt grote projecten, met complexe afhankelijkheden, makefiles zelf schrijven op een platformonafhankelijke en configureerbare manier sterk afgeraden wordt. Tegenwoordig gebruikt men vaak tools die, gebaseerd op een high-level beschrijving en handig configureerbare instellingen voor jou zelf (complexe) makefiles genereren. Een tool die vaak gebruikt wordt hiervoor is CMake, dat je kan vinden op \url{https://cmake.org/}/

\chapter{Administratietaken op Linux}
Veel Linux-distributies komen met een grote verscheidenheid aan pakketten die je makkelijk kan installeren. Debian-gebaseerde systemen (waarvan het systeem op de VM er een is), maken hiervoor gebruik van het \verb!apt!-commando. Met die tool kan je door de verschillende installeerbare pakketten zoeken, ze installeren, etc. (Debian-gebaseerde systemen bieden voor die taken ook de commando's \verb!apt-get! en \verb!apt-cache! aan, die je misschien soms ook in on-line manuals zal tegenkomen. Die kan je hier nu even negeren.)

Zoeken naar pakketten doe je met \verb!apt search! \emph{keywords}. Stel dat je weet dat er een pakket is met een tool die allerhande bewerkingen met het klembord (\emph{clipboard}) toestaat. Dan kan je naar dit pakket zoeken als volgt:
\begin{verbatim}
student@student-VirtualBox:~$ apt search clipboard tool
Sorting... Done
Full Text Search... Done
deepin-picker/testing 1.6.4-1 amd64
  Color picker tool for deepin

....
....

xsel/testing,now 1.2.0+git9bfc13d.20180109-1 amd64 [installed,automatic]
  command-line tool to access X clipboard and selection buffers
\end{verbatim}

Wil je een uitgebreidere beschrijving van een pakket waarvan je de naam weet, kan je die verkrijgen met \verb!apt show! \emph{pakketnaam}:

\begin{verbatim}
student@student-VirtualBox:~$ apt show xsel
...
Description: command-line tool to access X clipboard and selection buffers
 XSel is a command-line program for getting and setting the contents of
 the X selection.  It can also append and have it follow a growing file
 (similar to tail -f).
...
\end{verbatim}

Paketten installeren doe je met \verb!apt install! \emph{pakketnaam}.

\textbf{Opgelet}: pakketten moet je installeren als de administrator, niet als gewone gebruiker. Totnogtoe hebben we alles als de gewone \verb!student!-gebruiker kunnen doen. Nu volstaat dit niet. Om taken uit te voeren als adminstrator (die gebruiker heet onder Linux-systemen de \verb!root!-gebruiker), kan je dit doen met het \verb!sudo!-commando. Dit commando kan je gebruiken om andere commando's uit te voeren onder het account van een andere gebruiker (standaard is dit als \verb!root!), mits je account daar de juiste privileges voor hebt. Je moet dan, voor de veiligheid, eerst nog eens het wachtwoord van jezelf ingeven:

\begin{verbatim}
student@student-VirtualBox:~$ sudo apt install xsel
[sudo] password for student: 
....
\end{verbatim}

Wil je de lijst paketten bijwerken met de meest actuele versies, moet je dit doen met \verb!apt update! (als \verb!root!-gebruiker).

Indien je ooit een \verb!bash!-shell zou willen opstarten als \verb!root!-gebruiker, dan doe je dit met \verb!sudo su! (maar let dan \emph{h\'e\'el} goed op met wat je doet, want voor je het weet heb je je systeem om zeep geholpen \verb!:)!).
\part{Week 3}

To be continued \verb!:)!

\chapter{Remote shell}

% https://gaia.ugent.be/helios/account.cgi
% ksh -> bash
% 
% \chapter{Bestandsyssteemoperaties combineren met pipes}
% Soms kan het ook handig zijn dat we een operatie willen toepassen op een aantal verschillende bestanden. We kunnen zoals hierboven altijd manueel dit bestand opgeven als argument aan het eerste commando. Soms weet je echter op voorhand niet welke bestanden dit allemaal zijn. Bijvoorbeeld wil je alle bestanden die eindigen op \verb!.backup! verwijderen met het \verb!rm!-commando. Dit kan je in twee stappen doen: een tool die je bestanden zoekt en print naar zijn standard output, en een tool die leest van zijn standard input, en elk van de bestanden daarop een actie kan uitvoeren.
% 

\end{document}
