\documentclass[a4paper,twoside,openany]{memoir}
\usepackage[dutch]{babel}
\usepackage{hyperref}
\usepackage{fullpage}

\epigraphfontsize{\small\itshape}
\setlength\epigraphwidth{8cm}
\setlength\epigraphrule{0pt}

\begin{document}

\epigraphfontsize{\small\itshape}

\chapter{Inleiding tot Linux}
\epigraph{``It’s a Unix system, I know this!''}{--- \textup{Lex Murphy}, Jurassic Park}

De komende drie weken gaan we een korte inleiding geven tot Linux. Maar wat is
Linux? Strikt genomen is Linux niet meer dan een \emph{operating system kernel}:
deze zorgt er achter de schermen voor dat je verschillende programma's kan
starten en tegelijkertijd laten draaien, dat de invoer die je via een
toetsenbord ingeeft bij de programma's toekomt, dat deze programma's iets op
het scherm kunnen printen als uitvoer, etc. Een gebruiker interageert echter
niet direct met de (Linux-)kernel, maar eerder met programma's die als interface
dienen. Meestal voorzien deze programma's een grafische interface: je bent dit
wel gewend uit Windows en OS X, en deze interfaces bestaan ook onder Linux,
zoals KDE en Gnome. Grafische, intuïtieve, interfaces zijn echter pas redelijk
laat in gebruik genomen. Voorafgaand de opkomst van de grafische interface aan
was er een andere interface die de computerwereld domineerde: de
\emph{command-line} interface.

Deze inleidende sessies gaan over de command-line interface (of
\emph{commandolijninterface}). Deze is  helaas (veel) minder intuïtief, maar
daarom niet minder belangrijk is om wat ervaring mee te hebben. Met enige kennis
van de command-line programma's, en hoe je die kan combineren met elkaar, kan je
je leven later (hopelijk) veel makkelijker maken (en dat niet alleen in de
eigenlijke practica van \emph{computerarchitectuur}, maar ook in andere vakken
van de opleidingen computerwetenschappen en elektrotechniek, en misschien zelfs
je thesis). Een grote sterkte van de command line op Linux (die voortvloeit uit
een rijke traditie van command line interfaces die ontstaan is in de jaren '70
en '80 en ontwikkeld werden voor Unix-systemen), is dat deze het zeer eenvoudig
maken om zeer complexe tekstoperaties en bestandssysteemoperaties met elkaar te
combineren. De uitvoer van veel programma's is simpelweg tekst, wat het
uitermate handig maakt om de uitvoer van programma's te filteren, combineren,
etc. Bij wijze van voorbeeld: je kan alle PDF-bestanden zoeken op je systeem, en
die dan filteren op degenen die de tekst \emph{``Voorstel tot het bevriezen van
$n$ postgraduaatsopleidingen''} bevatten, waarbij $n$ gelijk welk natuurlijk
getal is; je kan de uitvoer van een simulator zo herstructureren dat je de
interessante data rechtstreeks in een spreadsheet kan plakken, etc.

\section{Organisatie van de sessies}

Deze inleidende sessies gaan door tijdens de eerste drie lesweken, elke dinsdag
van 8u30 tot 9u40, in PC-klassen A en B in de Plateau. Je gaat hier op twee
manieren met Linux leren werken:

\begin{enumerate}

  \item Met enkele oefeningen op Dodona. Deze oefeningen zullen gradueel
    beschikbaar gemaakt worden op de Dodona-site die je kan vinden op
    \url{https://dodona.ugent.be/nl/courses/79/}.

  \item Door te oefenen op een virtueel Linux-systeem dat jullie in VirtualBox
    zullen opzetten. Installeer hiervoor eerst VirtualBox
    (\url{https://www.virtualbox.org/}), end download onze image op
    \url{https://users.elis.ugent.be/~bcoppens/kubuntu-computerarchitectuur.7z}.
    \textbf{Gelieve deze stappen reeds op voorhand te voltooien zodat we hier
    tijdens de labo's zelf niet te veel tijd aan verliezen.} Indien je wil
    werken op een PC in de practicumzaal, zet dan best de (gedecomprimeerde)
    image al op een USB stick. Op dit Linux-systeem hebben we voor jullie al
    een gebruiker \emph{student} aangemaakt wiens \textbf{wachtwoord} ook
    simpelweg \emph{student} is.

\end{enumerate}

De structuur van de sessies zal er als volgt uitzien (voorlopige planning, onder voorbehoud):

\begin{itemize}

  \item \emph{Week 1}: Inleiding tot de command line, de meest simpele
    bestandssysteemoperaties, eenvoudige tekstoperaties, en \emph{reguliere
    expressies}.

  \item \emph{Week 2}: Het combineren van verschillende operaties tot veel
    krachtigere en complexere pijplijnen aan de hand van \emph{pipes} en
    \emph{redirects}, geavanceerdere reguliere expressies, en hoe simpele
    C(++)-programma's te compileren vanaf de command line.

  \item \emph{Week 3}: Meer geavanceerde toepassingen van de concepten van de
    eerste twee weken, Linux-systemen op het internet beheren met een
    \emph{remote shell}, en een korte introductie tot \emph{git}.

\end{itemize}

Het materiaal behorende tot weken 2 en 3 zal voor die lessen online komen.
\textbf{Deze handleiding zal dus ook nog twee keer aangepast worden met het nu
nog ontbrekende materiaal van weken 2 en 3!}

\part{Week 1}
\chapter{Het bestandssysteem in Linux}
Voor we beginnen met het echte werk, is het nuttig om enkele basisconcepten
te kennen van het bestandssysteem, en hoe je kan verwijzen naar bestanden.

Standaard zijn alle verwijzingen naar bestanden \emph{relatief ten opzichte van
de huidige directory}. Dus als je weet dat je directory zit die een
(sub)directory \verb!computerarchitectuur_practica! bevat, kan
je met de verwijzijng \verb!computerarchitectuur_practica! direct naar deze
subdirectory verwijzen.

Directories en bestanden daarin worden van elkaar gescheiden door een forward
slash (/). Dus, \verb!computerarchitectuur_practica/README! verwijst naar
het \verb!README!-bestand in de \verb!computerarchitectuur_practica! directory.

Merk op dat voor Linux een directory eigenlijk een speciaal bestand is. Dus
als je vraagt om alle bestanden in een directory op te lijsten, zal je dus
niet alleen de `gewone' bestanden zien, maar ook alle (sub)directories.

Je kan ook werken met \emph{absolute paden}. In Windows is dit typisch iets wat
begint met \verb!C:\!, \verb!D:\!, etc.. In Unix-gebaseerde systemen zoals
Linux (maar ook OS X),
beginnen deze echter steeds met een initiële forward slash. Alle bestanden zijn
dus te vinden via verwijzingen die starten vanaf de zogeheten
\emph{root-directory}. Al je schijven, USB-sticks, etc., zitten in eenzelfde
directorystructuur. Een voorbeeld van zo'n pad is de
home-directory van de gebruiker: \verb!/home/student!. Dit wil zeggen dat we starten vanaf de
root-directory \verb!/!, die een subdirectory \verb!home! bevat, die dan op zijn
beurt een subdirectory \verb!student! bevat.


\chapter{Inleiding tot de command line}

Start in je Linux virtuele machine een \emph{terminal} op door het programma
\emph{Konsole} te starten. (Zoals zo vaak in de Linux-wereld zijn er
duizend-en-één verschillende mogelijkheden beschikbaar, waarvan Konsole er
slechts één is.) Eerst gaat dit wat uitvoer produceren die je voorlopig mag
negeren (er start namelijk een programma dat automatisch de meest recente
opgaves op je systeem zal downloaden). Na even te wachten, zal je dan volgende
\emph{prompt} te zien krijgen:

\begin{verbatim}
student@student-VirtualBox:~$ 
\end{verbatim}

Deze prompt vraagt (of `prompt') achter nieuwe commando's om uit te voeren. De
tekst duidt aan dat deze sessie draait op het systeem genaamd
\emph{student-VirtualBox} (later zullen we inloggen op een ander systeem met een
andere naam), als gebruiker \emph{student}. De naam van de gebruiker vind je dus
voor de \texttt{@}, de naam van het systeem na de \texttt{@}. Wat er tussen de
\texttt{:} en de \texttt{\$} staat, is de \emph{directory} waar je je op dit
moment bevindt. Standaard zal een terminal starten in de \emph{home-directory}
van de ingelogde gebruiker; deze wordt doorgaans afgekort als \texttt{\~}.

Om er achter te komen in welke directory we ons eigenlijk bevinden, gaan we het
eerste commando invoeren, \verb!pwd! (\emph{Print Working Directory}):

\begin{verbatim}
student@student-VirtualBox:~$ pwd
/home/student
\end{verbatim}

In de loop van deze sessies zal je nog veel meer van deze commando's tegenkomen
met enigszins obscure namen, waar je een hele reeks meer en minder gekende
opties aan kan meegeven. Om meer te lezen over een bepaald commando en de opties
die het ondersteunt kan je beroep doen op de \emph{man-pages}, die een soort van
handleiding vormen. Je kan deze opvragen met het commando \verb!man!. Stel je
voor dat je je afvraagt wat de mogelijke opties zijn van het \verb!ls!-commando
(dat we zometeen gaan zien). Dit doe je via:

\begin{verbatim}
student@student-VirtualBox:~$ man ls
\end{verbatim}
waarna je in een zeer simpele textviewer terecht komt met de handleiding van het
\verb!ls!-commando. Helemaal bovenaan staan heel summiere uitleg van wat het
programma doet, een summier overzicht van de mogelijke opties, gevolgd door een
heel uitgebreide beschrijving van al die opties, eventueel gevolgd door
voorbeelden en aandachtspunten. Deze viewer moet echter ook op een specifieke
manier bediend worden:

\begin{itemize}

  \item \emph{Scrollen} door de tekst kan je met de pijltjes omhoog en omlaag,
    en door PageUp en PageDown.

  \item \emph{Zoeken} door de tekst, kan je door forward slash (`/') te typen,
    gevolgd door je zoekterm (als je bijvoorbeeld in het geval van \verb!ls! wil
    weten hoe de uitvoer gesorteerd kan worden, kan je `sort' typen), en dan op
    \emph{enter} duwen. Alle hits op die zoekterm zullen oplichten in de tekst,
    en de viewer springt automatisch naar de eerste hit. Je kan bovendien
    eenvoudig naar de volgende/vorige hit in de tekst gaan met respectievelijk
    de toetsen `n' (\emph{next}) en `p' (\emph{previous}).

  \item {Afsluiten} van de viewer kan je doen door de `q'-toets (\emph{quit}).

\end{itemize}

\chapter{Simpele bestandssysteemoperaties}

We gaan een aantal heel simpele bestandssysteemoperaties bekijken. Vergeet niet
dat je meer details hierover (zoals extra opties) kan opzoeken in de relevante
man-pages.

\section{\texttt{ls} --- List Files/Directory Contents}

Het \verb!ls!-commando laat toe om de inhoud van een directory te bekijken, en
om meer details over de  bestanden weer te geven. Als je geen specifieke
bestanden of directories meegeeft als argument, dan zal het informatie
uitprinten over de huidige
directory. Standaard zal het \emph{énkel} de lijst van bestanden (en dus ook
directories) in de huidige directory uitprinten:

\begin{verbatim}
student@student-VirtualBox:~$ ls
computerarchitectuur_practica Desktop Documents Downloads Music Pictures Public
Templates Videos
\end{verbatim}

Dit wil dus zeggen dat je home-directory 9 bestanden (in dit geval alleen
directories) bevat.

Je de bestanden in die (sub)directory als volgt printen: \verb!ls computerarchitectuur_practica!
(merk dus op dat we hier nu gebruiken van een relatief pad). Je kan even
goed ook verwijzen naar een subdirectory: Nu je weet dat in die directory
een subdirectory \verb!pract01!
zit, kan je die inhoud laten zien door het commando
\verb!ls computerarchitectuur_practica/pract01!
te typen.


\textbf{Belangrijke tip!} Je gaat het misschien net als ik ook al beu zijn om
elke keer opnieuw \verb!computerarchitectuur_practica! voluit te typen. Dat is
saai, traag, en foutgevoelig. De \emph{shell} (het programma waarmee je
interageert in de terminal en die je \verb!student@student-VirtualBox:~$!
print), heeft gelukkig een feature die dit probleem zo goed als volledig oplost:
\emph{tab completion}. Je typt gewoon het begin van een bestand/directory, en
drukt de tab-toets in. De shell zal dan zo ver mogelijk aanvullen als hij kan,
gegeven de bestanden in de directory. Dus bij
\verb!computerarchitectuur_practica! weet je nu dat dit het \'enige bestand is
in de home-directory dat begint met de letter \verb!c!. Dus kan je gewoon typen:
\verb!ls c!\emph{tab}, waarna automatisch alles wordt aangevuld. Die directory
heeft nu 8 practica-subdirectories. Dus kan je
\verb!computerarchitectuur_practica/p!\emph{tab} typen, waarna dit wordt
aangevuld tot \verb!computerarchitectuur_practica/pract0!. Aangezien er echter 8
verschillende subdirectories zijn, kan de shell dit uiteraard niet aanvullen tot
op het einde. In dit geval is het handig om 2 keer op tab te duwen:
\verb!computerarchitectuur_practica/pract0!\emph{tab} \emph{tab}: dan laat de
shell alle bestanden zien die beginnen met \verb!pract0!, zodat je makkelijk dat
karakter zelf kan typen (en dan eventueel weer verder aan te laten vullen door
weer op \emph{tab} te duwen).

Probeer eens op de volgende 3 manieren de inhoud van
\verb!computerarchitectuur_practica! te laten zien: met een relatief pad, met
een absoluut pad, en met een pad relatief ten opzichte van de shortcut voor de
homedirectory \verb!~!. Maak hierbij gebruik van tab completion.

Je kan ook meer informatie laten printen door \verb!ls!. De meest handige manier
is \verb!ls -lh!, wat onder andere de grootte print van het bestand. Probeer dit
eens uit met \verb!ls -lh /bin/!. Gebruik de man-page om te achterhalen wat de
\verb!l! en \verb!h! opties precies betekenen. (Voor de rest is het allicht ook
interessant om weten dat je kan sorteren op allerhande soorten informatie, als
je meer hierover wil weten kan je dat opzoeken in de man-page.)

\section{\texttt{cd} --- Change Directory}

Enerzijds kennen we nu het concept van `de huidige directory', en anderzijds
weten we hoe \verb!ls! te gebruiken om te zien welke directories (of files) er
waar zijn. Met \verb!cd! kunnen we onze huidige directory veranderen naar de
andere directory. Zo kunnen we naar de
\verb!computerarchitectuur_practica!-directory gaan, en verolgens het
\verb!ls!-commando uitvoeren. De inhoud van de
\verb!computerarchitectuur_practica!-directory zal dan getoond worden:

\begin{verbatim}
student@student-VirtualBox:~$ cd computerarchitectuur_practica
student@student-VirtualBox:~/computerarchitectuur_practica$ ls
pract01 pract02 pract03 pract04 pract05 pract06 pract07
pract08 README
\end{verbatim}

De prompt geeft hier meteen mooi aan dat de huidige directory veranderd is.

Je kan verwijzen naar de bovenliggende directory via \verb!..!. Dit kan je
gebruiken om omhoog te gaan in de directorystructuur:
\begin{verbatim}
student@student-VirtualBox:~/computerarchitectuur_practica$ cd ../..
student@student-VirtualBox:/home$ 
\end{verbatim}

Hier verplaatsen we ons dus naar de bovenliggende directory van de bovenliggende
directory, wat in dit geval \verb!/home! is.

\section{\texttt{mkdir} --- Make Directory}

We kunnen nieuwe directories aanmaken met het \verb!mkdir! commando: \verb!mkdir nieuwedirectory!. De verwijzing naar de nieuwe directory kan zowel relatief als
absoluut zijn, maar standaard gaat het commando er van uit dat slechts de meest
diepe directory moet worden aangemaakt, en alle tussenliggende directories reeds
bestaan. Zoek op in de man-page hoe je \verb!mkdir! deze directories ook kan
laten aanmaken voor je.

\section{\texttt{cp} --- CoPy Files}

Met het \verb!cp!-commando kan je bestanden kopiëren. Er zijn twee mogelijkheden:

\begin{itemize}

  \item Het doel is een bestandsnaam: \verb!cp bestand1 bestand2! zal
    \verb!bestand1! kopiëren naar een bestand met de naam \verb!bestand2!.

  \item Het doel is een directory: \verb!cp bestand1 directory! zal een kopie
    van \verb!bestand1! aanmaken in \verb!directory!; het nieuwe bestand zal (in
    die directory) dezelfde naam hebben als het originele bestand. In dit geval
    kan je ook meerdere bestanden in 1 keer kopieren: \verb!cp bestand1 bestand2 bestand3 directory!.

\end{itemize}

Probeer eens een bestand uit de \verb!/bin!-directory te kopiëren naar een
directory die je zonet hebt aangemaakt, en verifieer dat de kopie even groot is
als het origineel.

\section{\texttt{mv} --- MoVe Files}

Het \verb!mv!-commando werkt net als het \verb!cp!-commando, maar het verplaatst
de bestanden in plaats van ze te kopiëren. Volledig gelijkaardig met \verb!cp!
kan het doel een bestandsnaam of een directory zijn.

\section{\texttt{rm} --- ReMove Files}

Tot slot willen we ook bestanden kunnen verwijderen. Dit kan met het
\verb!rm!-commando.

\section{\texttt{cat} --- Een slechte textviewer}

Het \verb!cat!-commando gaat de inhoud van bestanden die het meekrijgt als
argument gewoon achter elkaar naar scherm printen. Probeer eens een bestand uit
de \verb!computerarchitectuur_practica! directory op scherm te printen.

\section{\texttt{less} --- Een simpele textviewer}

Het \verb!cat!-commando is niet zo handig om tekst mee te bekijken. Het zou veel
handiger zijn als we de textviewer die gebruikt wordt voor de man-pages zouden
kunnen hergebruiken. Gelukkig is dit mogelijk: dit is het \verb!less!-commando.
Probeer met \verb!less! eens hetzelfde bestand te bekijken als je zonet deed met
\verb!cat!.

\section{\texttt{touch} --- Een leeg bestand aanmaken}

Met het \verb!touch!-commando kan je een leeg bestand aanmaken. (Dit commando
heeft eigenlijk een ander doel, zoals je kan lezen in de man-page. Maar als je
het als argument een bestandsnaam geeft die nog niet bestaat, zal het dat
bestand aanmaken.)

Maak in je homedirectory eens een leeg bestand \verb!A! aan. Net zoals bij de
vorige commando's, kan je ook meerdere argumenten aan dit commando meegeven. Elk
van die bestanden zal dan worden aangemaakt.

\textbf{Belangrijk!} De verschillende argumenten van een commando worden door
een spatie van elkaar gescheiden. Maar als nu een van de argumenten een
bestandsnaam is die een spatie bevat, wat dan? Dan kan je dat argument tussen
een koppel enkele quote-tekens (\verb!'!) zetten: alles wat daartussen staat,
wordt beschouwd als hetzelfde argument, inclusief spaties. Als we bijvoorbeeld 3
bestanden willen aanmaken, waarvan één bestand wiens naam spaties bevat, kan je
dit als volgt doen:

\begin{verbatim}
student@student-VirtualBox:~$ touch bestand1 'bestandsnaam 2 met spaties' bestand3
\end{verbatim}

Probeer dit zelf eens, en kijk ook hoe dit er uit ziet met zowel \verb!ls! als
\verb!ls -lh!. Probeer zo'n bestand ook eens te kopiëren. Merk bovendien ook op
dat het geen kwaad kan om ook quote-tekens te zetten rond argumenten zonder
spatie:

\begin{verbatim}
student@student-VirtualBox:~$ touch 'bestand4' 'bestand5'
\end{verbatim}

Dit zal 2 extra bestanden aanmaken, waarbij de quotes geen deel uitmaken van de
bestandsnaam. Je kan in principe ook dubbele quotes (\verb!"zoals dit"!)
gebruiken, maar die hebben een subtiel andere betekenis dan de enkele quote die
ik hierboven demonstreerde. Het verschil zal je zien in sessie 3; gebruik tot
dan voor de veiligheid gewoon de enkele quotes.

\chapter{Simpele tekstoperaties}

Nu gaan we ook echt iets doen met deze tekstbestanden. In deze sessie houden we
het eenvoudig: we gaan simpelweg de inhoud van bestanden doorzoeken en
herordenen.

\section{\texttt{cut} --- Herordenen van kolommen}

Met het \verb!cut!-commando kan je tekstbestanden onderverdelen in kolommen, en
dan een deelverzameling van die kolommen uitprinten op het scherm (in de
volgorde die jij wil). De kolommen (\emph{fields}) die je wil printen, geef je
aan met het argument dat volgt op \verb!-f!. Het \verb!cut!-commando verdeelt
een lijn onder in verschillende kolommen afhankelijk van een \emph{delimiter}.
Zoals je in de man-page al kan zien, is deze delimiter standaard een
tab-karakter, wat in de praktijk nogal onhandig is; die kan je makkelijk
aanpassen met \verb!-d!.

Om een simpel voorbeeld te geven, het bestand \verb!/etc/passwd! bevat
informatie over de gebruikers op het systeem. De verschillende velden zijn van
elkaar gescheiden door een \verb!:!-karakter. Als je dan bijvoorbeeld per
gebruiker de volledige naam (het vijfde veld) en de home-directory van die
gebruiker (het zesde veld) wil uitprinten, kan je dit doen als volgt:

\begin{verbatim}
student@student-VirtualBox:~$ cut -d : -f 5,6 /etc/passwd
\end{verbatim}

Probeer eens een spatie als delimiter te gebruiken?

\chapter{Reguliere expressies}

Reguliere expressies zijn uitdrukkingen die je toestaan om simpele zoekpatronen
(dit zijn dan de expressies) te beschrijven die meer zijn dan enkel letterlijke
stukken tekst. Achter dit concept zit een heel interessante theoretische
achtergrond, die volledig buiten de scope van dit document valt. Wat belangrijk
is, is wat je er mee kan en hoe je ze opbouwt.

Je doorzoekt een of meerdere tekstbestanden met een reguliere expressie als
volgt: \verb!egrep '!\emph{patroon}\verb!' bestand(en)!. Dit gaat alle lijnen
uitprinten in de gegeven bestanden die voldoen aan de gegeven reguliere
expressie/zoekpatroon. Zo'n patroon zet je opnieuw best tussen quotes, niet
alleen omdat een patroon spaties kan bevatten, maar ook omdat bepaalde
zoekpatronen speciale karakters zijn in de shell, en door die in quotes te
zetten verliezen ze hun speciale betekenis.

Een regulier expressie bouw je op uit kleinere sub-expressies. De belangrijkste sub-expressies en manieren om ze op te bouwen zijn:

\begin{itemize}

  \item \emph{Letterlijk karakter:} Dit geef je gewoon letterlijk in.
    Bijvoorbeeld: \verb!egrep 'a' bestand.txt! zoekt geeft alle lijnen die het
    karakter \emph{a} bevatten in het bestand \verb!bestand.txt!

  \item \emph{Aan elkaar plakken van expressies (concatenation)}: door
    expressies achter elkaar te plakken, ga je zoeken op de regels die die
    opeenvolging van expressies bevatten. Zoals je weet van het vorige puntje,
    is een enkel karakter een expressie; je kan die dan zoals je zou verwachten
    achter elkaar typen om volledige zinnen te zoeken. Bijvoorbeeld,
    \verb!egrep 'Linux is tof' bestand.txt! zoekt op de tekst \emph{Linux is
    tof} (dat is dus de opeenvolging van de tekens \emph{L, i, n, etc.} in het
    bestand \verb!bestand.txt!.

  \item \emph{Eender welk karakter:} Als je het \verb!.!-karakter in een
    reguliere expressie op een bepaalde plaats zet, zal gelijk welk karakter
    daar mogen voorkomen. Bijvoorbeeld: \verb!egrep 'm.h' bestand.txt! zal alle
    regels uitprinten die tekst bevatten die de vorm heeft van `m, gevolgd door
    gelijk welk karakter, gevolgd door h'.

  \item \emph{Een bereik (range) van karakters:} soms is \verb!.! te ruim, en
    wil je enkel regels die op een bepaalde positie een beperkt bereik van
    karakters toestaan. Dit kan je doen door al die karakters tussen vierkante
    haakjes te zetten. Bijvoorbeeld: \verb!Bar[td]! is een patroon dat zowel
    \emph{Bart} als \emph{Bard} zal matchen. Als het bereik groot is, maar op
    elkaar volgt in de ASCII-tabel, kan je dit afkorten door een streepje: het
    patroon \verb![a-d]! zal \emph{a,b,c,d} matchen.

  \item \emph{Een keuzemogelijkheid:} als je lijnen wil printen die een van
    meerdere zoekpatronen matcht, kan je die scheiden van elkaar met een
    vertikaal streepje, ook wel het \emph{pipe symbol} genoemd: \verb!|!.
    Bijvoorbeeld, \verb!Aap|Noot|Mies! zal alle lijnen printen die minstens
    eenmaal \emph{Aap}, \emph{Noot}, of \emph{Mies} bevatten.

  \item \emph{Herhaling, 0 of meer keer:} Als je het voorgaande element 0 of
    meer keer wil herhalen, dan zet je hier een asterisk na: \verb!ka*t! zal
    zowel matchen op \emph{kt}, \emph{kat}, \emph{kaat}, etc. Dit werkt
    uiteraard ook op andere types referenties, \verb![0-9]*! zal matchen op
    gelijk welke opeenvolging van cijfers (en ook 0 cijfers).

  \item \emph{Herhaling, 1 of meer keer:}, hiervoor gebruiken we een plus-teken.
    Dus \verb![0-9]+! zal matchen op elk getal, dat minstens uit \'e\'en cijfer
    bestaat.

  \item \emph{Herhaling, bereik:} dit doe je met accolades en het aantal keer
    dat het herhaald wordt ertussen. Bijvoorbeeld, als je exact een Googol wil
    matchen, wat een 1 is gevolgd door 100 0'en, dan kan je dit doen als volgt:
    \verb!10{100}!. (Dus om precies te zijn: het element voor de accolades is
    een 0, en dat moet 100 keer worden herhaald.) Je kan ook een heel bereik
    opgeven (tussen twee getallen, ten hoogste een bepaald getal), de exacte
    syntax hiervan kan je in de man-page van egrep vinden.

  \item \emph{Groeperen:} De bovenstaande operaties slaan steeds op het vorige
    \emph{element} in de expressie. Aangezien individuele karakters ook al
    expressies zijn, wil dit zeggen dat de expressie \verb!Noot{2}! \'enkel zal
    matchen op \emph{Noott} (dus een dubbele \emph{t}), maar ni\'et op
    \emph{NootNoot}. Om die operaties op een samenstelling van expressies te
    zetten, zet je die samenstelling tussen ronde haakjes. Wat tussen ronde
    haakjes staat, zal dan worden aanzien als een enkele expressie. Dus om
    \emph{NootNoot} te matchen, kan je dus de expressie \verb!(Noot){2}!
    gebruiken.

  \item \emph{Begin van een regel:} Dit geef je aan met het teken \verb!^!. Dus
    \verb!^A! gaat enkel op regels matchen die beginnen met een \emph{A}.

  \item \emph{Einde van een regel:} Dit geef je aan met het teken \verb!$!. Dus
    \verb!A$! gaat enkel op regels matchen die eindigen op een \emph{A}.

\end{itemize}

Een voorbeeldje:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd
\end{verbatim}

zal alle regels in \verb!/etc/passwd! uitprinten die eindigen op ofwel
\verb!nologin! ofwel op \verb!false!. Bovendien zal de omgeving die wij
gebruiken, \verb!egrep! standaard zo instellen dat de specifieke delen die
gematcht worden, gekleurd worden, zodat je duidelijk kan zien waar de matchende
expressies voorkomen in elke lijn.

Standaard gaat \verb!egrep! hoofdlettergevoelig zoeken. Dit wil zeggen dat \verb!egrep 'e'! niet hetzelfde is als \verb!egrep 'E'!: het eerste zal enkel lijnen weergeven die een kleine letter \emph{e} bevatten, het tweede enkel lijnen met een hoofdletter \emph{E}. Je kan die hoofdlettergevoeligheid uitzetten met de \verb!-i! optie: \verb!egrep -i 'e'! zal zowel de hoofdletter als kleine letter \emph{e} matchen.

Tot slot kan je \verb!egrep! ook gebruiken om de zoekpatronen te \emph{inverteren}: met de \verb!-v! optie (inVert), inverteer je het zoekpatroon: \verb!egrep! zal dan enkel de lijnen uitprinten die \emph{ni\'et} voldoen aan het zoekpatroon.

\textbf{Oefeningen} Op Dodona kan je hierover enkele extra oefeningen vinden! Ik zou aanraden om deze zeker te maken.

\part{Week 2}

\chapter{Redirects}
We hebben vorige week gezien hoe we tekstoperaties konden doen op bestanden. Op zich waren die weliswaar reeds nuttig afzonderlijk; maar deze week gaan we kijken hoe we die veel nuttiger kunnen maken: we gaan de uitvoer van programma's opvangen en daar allerhande dingen mee doen.

Wellicht is het je vorige week bij de Dodona-oefening over \verb!strings! ook opgevallen: dat waren heel veel lijnen die over het scherm raasden, dat is niet heel nuttig. We zouden graag iets doen met die uitvoer. We gaan beginnen met de uitvoer te \emph{redirecten} naar een bestand. In de meest simpele manier om dit te doen, geef je dit aan met een groter-dan teken te plaatsen na het commando, gevolgd door een bestandsnaam waar de uitvoer naar geschreven moet worden. Bijvoorbeeld:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd > bestand.txt
\end{verbatim}

maakt het bestand \verb!bestand.txt! aan in de huidige directory (in dit geval: de home-directory), met daarin de uitvoer van het \verb!egrep!-commando.

Probeer zelf eens de uitvoer van een van je commando's van vorige week naar een bestand te schrijven.

Natuurlijk rijst dan de vraag: wat gebeurt er als je de uitvoer redirect naar een bestand dat reeds bestaat? Dit bestand wordt dan \emph{overschreven}. Wil je dat de uitvoer van een programma achteraan een reeds bestaand bestand wordt toegevoegd (\emph{appended}), dan gebruik je een dubbele groter-dan:

\begin{verbatim}
student@student-VirtualBox:~$ egrep '(nologin|false)$' /etc/passwd >> bestand.txt
\end{verbatim}

zal de uitvoer van het \verb!egrep!-commando \emph{achteraan toevoegen} aan \verb!bestand.txt!.

Zoals je misschien echter weet, kunnen programma's uitvoer wegschrijven via verschillende \emph{output soorten (output)stream}, die onafhankelijk zijn van elkaar. Het gaat hier over de \emph{standard output} (in Python is dit waar je standaard via \verb!print()! impliciet naar schrijft, of expliciet naar schrijft via \verb!sys.stdout!; in Java is dit \verb!System.out!), en \emph{standard error} (in Python is dit \verb!sys.stderr!, in Java is dit \verb!System.err!).

Het redirecten van uitvoer met een (enkele of dubbele) groter-dan zoals hierboven slaat \'enkel op standard output. Fouten zullen dus niet geredirect worden:

\begin{verbatim}
student@student-VirtualBox:~$ ls /dit/bestand/bestaat/niet > bestand.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ cat bestand.txt
student@student-VirtualBox:~$
\end{verbatim}

Wil je \'enkel de standard error redirecten, dan doe je dit met de syntax \verb!2>!. Wil je samen standard output en standard error redirecten naar eenzelfde bestand, dan doe je dit met de syntax \verb!&>!:

\begin{verbatim}
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet 2> error.txt
/etc/passwd
student@student-VirtualBox:~$ cat error.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet 2> error.txt > bestand.txt
student@student-VirtualBox:~$ cat bestand.txt
/etc/passwd
student@student-VirtualBox:~$ cat error.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
student@student-VirtualBox:~$ ls /etc/passwd /dit/bestand/bestaat/niet &> alles.txt
student@student-VirtualBox:~$ cat alles.txt
ls: cannot access '/dit/bestand/bestaat/niet': No such file or directory
/etc/passwd
\end{verbatim}

\chapter{Pijplijnen van commando's}
Heel veel van de Linux-tools voor tekstoperaties die we eerder gezien hebben, zoals \verb!egrep!, kunnen die operaties niet enkel toepassen op bestanden, maar ook op \emph{hun input stream}. Door geen bestanden als argument mee te geven, gaat zo een tool automatisch de tekstoperaties uitvoeren op de standard input (en zoals altijd de uitvoer naar standard output sturen). (In het geval dat je eens een programma opstart zonder bestandsargumenten, dan kan je de inputstream afsluiten door op \emph{Ctrl+d} in te drukken. Probeer dit zelf eens met \verb!egrep 'Hallo'!, en dan eens zowel niet-matchende tekst als \emph{Hallo} in te geven.

Nu je weet dat zulke tools ook een stream als invoer kunnen gebruiken, is de logische volgende stap natuurlijk om de invoer en uitvoer van meerdere tools aan elkaar te hangen (er een pijplijn maken). Zo kan je bijvoorbeeld de uitvoer van een \verb!egrep!-operatie doorsturen als input van een \verb!cut!-operatie. Dit doen we door middel van de vertikale streep (\verb!|!, ook wel \emph{pipe} genoemd) tussen de operaties te zetten. Bijvoorbeeld:
\begin{verbatim}
student@student-VirtualBox:~$ egrep 'student' /etc/passwd | cut -d : -f 6
/home/student
\end{verbatim}

houdt enkel de lijnen van \verb!/etc/passwd! over die \emph{student} bevatten, en gaat enkel die lijnen onderverdelen in kolommen (met : als delimiter), en print daarvan de 6e kolom. Je kan je pijplijnen zo lang maken als je zelf wil. Uiteindelijk kan je dan het eindresultaat naar een bestand wegschrijven om later te editeren of bekijken. Een andere handige tip is om het \verb!less!-commando de laatste stap van je pijplijn te maken: dan kan je makkelijk scrollen en zoeken in het resultaat.

Probeer eerst zelf eens als opwarmertje om in de woordenboek die je kan vinden op \verb!/usr/share/dict/words! te doorzoeken op alle woorden die eindigen op het suffix \emph{ily}, en pipe die naar het \verb!less!-commando.

Op Dodona vind je nog een reeks opgaven die gaan over pijplijnen met simpele tekstoperaties. Probeer deze op te lossen.

\chapter{Geavanceerde reguliere expressies}

NOOT: OOK IN PYTHON

\chapter{Andere operaties}
find, xargs

\chapter{Compileren op de command line}

\part{Week 3}

To be continued \verb!:)!

\chapter{Remote shell}

% https://gaia.ugent.be/helios/account.cgi
% ksh -> bash

\end{document}
